! function (e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.Discord = t() : e.Discord = t()
}(window, (function () {
    return function (e) {
        var t = {};

        function s(i) {
            if (t[i]) return t[i].exports;
            var n = t[i] = {
                i: i,
                l: !1,
                exports: {}
            };
            return e[i].call(n.exports, n, n.exports, s), n.l = !0, n.exports
        }
        return s.m = e, s.c = t, s.d = function (e, t, i) {
            s.o(e, t) || Object.defineProperty(e, t, {
                enumerable: !0,
                get: i
            })
        }, s.r = function (e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, s.t = function (e, t) {
            if (1 & t && (e = s(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var i = Object.create(null);
            if (s.r(i), Object.defineProperty(i, "default", {
                    enumerable: !0,
                    value: e
                }), 2 & t && "string" != typeof e)
                for (var n in e) s.d(i, n, function (t) {
                    return e[t]
                }.bind(null, n));
            return i
        }, s.n = function (e) {
            var t = e && e.__esModule ? function () {
                return e.default
            } : function () {
                return e
            };
            return s.d(t, "a", t), t
        }, s.o = function (e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }, s.p = "", s(s.s = 83)
    }([function (e, t, s) {
        "use strict";
        (function (e) {
            const i = t.Package = s(49),
                {
                    Error: n,
                    RangeError: r
                } = s(3),
                o = t.browser = "undefined" != typeof window;
            t.DefaultOptions = {
                shardCount: 1,
                messageCacheMaxSize: 200,
                messageCacheLifetime: 0,
                messageSweepInterval: 0,
                fetchAllMembers: !1,
                disableMentions: "none",
                partials: [],
                restWsBridgeTimeout: 5e3,
                restRequestTimeout: 15e3,
                retryLimit: 1,
                restTimeOffset: 500,
                restSweepInterval: 60,
                presence: {},
                ws: {
                    large_threshold: 250,
                    compress: !1,
                    properties: {
                        $os: o ? "browser" : e.platform,
                        $browser: "discord.js",
                        $device: "discord.js"
                    },
                    version: 6
                },
                http: {
                    version: 7,
                    api: "https://discordapp.com/api",
                    cdn: "https://cdn.discordapp.com",
                    invite: "https://discord.gg"
                }
            }, t.UserAgent = o ? null : `DiscordBot (${i.homepage.split("#")[0]}, ${i.version}) Node.js/${e.version}`, t.WSCodes = {
                1e3: "WS_CLOSE_REQUESTED",
                4004: "TOKEN_INVALID",
                4010: "SHARDING_INVALID",
                4011: "SHARDING_REQUIRED",
                4013: "INVALID_INTENTS",
                4014: "DISALLOWED_INTENTS"
            };
            const a = ["webp", "png", "jpg", "gif"],
                c = Array.from({
                    length: 8
                }, (e, t) => 2 ** (t + 4));

            function l(e, {
                format: t = "webp",
                size: s
            } = {}) {
                if (t && !a.includes(t)) throw new n("IMAGE_FORMAT", t);
                if (s && !c.includes(s)) throw new r("IMAGE_SIZE", s);
                return `${e}.${t}${s?`?size=${s}`:""}`
            }

            function h(e) {
                let t = Object.create(null);
                for (const s of e) t[s] = s;
                return t
            }
            t.Endpoints = {
                CDN: e => ({
                    Emoji: (t, s = "png") => `${e}/emojis/${t}.${s}`,
                    Asset: t => `${e}/assets/${t}`,
                    DefaultAvatar: t => `${e}/embed/avatars/${t}.png`,
                    Avatar: (t, s, i = "webp", n, r = !1) => (r && (i = s.startsWith("a_") ? "gif" : i), l(`${e}/avatars/${t}/${s}`, {
                        format: i,
                        size: n
                    })),
                    Banner: (t, s, i = "webp", n) => l(`${e}/banners/${t}/${s}`, {
                        format: i,
                        size: n
                    }),
                    Icon: (t, s, i = "webp", n, r = !1) => (r && (i = s.startsWith("a_") ? "gif" : i), l(`${e}/icons/${t}/${s}`, {
                        format: i,
                        size: n
                    })),
                    AppIcon: (t, s, {
                        format: i = "webp",
                        size: n
                    } = {}) => l(`${e}/app-icons/${t}/${s}`, {
                        size: n,
                        format: i
                    }),
                    AppAsset: (t, s, {
                        format: i = "webp",
                        size: n
                    } = {}) => l(`${e}/app-assets/${t}/${s}`, {
                        size: n,
                        format: i
                    }),
                    GDMIcon: (t, s, i = "webp", n) => l(`${e}/channel-icons/${t}/${s}`, {
                        size: n,
                        format: i
                    }),
                    Splash: (t, s, i = "webp", n) => l(`${e}/splashes/${t}/${s}`, {
                        size: n,
                        format: i
                    }),
                    DiscoverySplash: (t, s, i = "webp", n) => l(`${e}/discovery-splashes/${t}/${s}`, {
                        size: n,
                        format: i
                    }),
                    TeamIcon: (t, s, {
                        format: i = "webp",
                        size: n
                    } = {}) => l(`${e}/team-icons/${t}/${s}`, {
                        size: n,
                        format: i
                    })
                }),
                invite: (e, t) => `${e}/${t}`,
                botGateway: "/gateway/bot"
            }, t.Status = {
                READY: 0,
                CONNECTING: 1,
                RECONNECTING: 2,
                IDLE: 3,
                NEARLY: 4,
                DISCONNECTED: 5,
                WAITING_FOR_GUILDS: 6,
                IDENTIFYING: 7,
                RESUMING: 8
            }, t.VoiceStatus = {
                CONNECTED: 0,
                CONNECTING: 1,
                AUTHENTICATING: 2,
                RECONNECTING: 3,
                DISCONNECTED: 4
            }, t.OPCodes = {
                DISPATCH: 0,
                HEARTBEAT: 1,
                IDENTIFY: 2,
                STATUS_UPDATE: 3,
                VOICE_STATE_UPDATE: 4,
                VOICE_GUILD_PING: 5,
                RESUME: 6,
                RECONNECT: 7,
                REQUEST_GUILD_MEMBERS: 8,
                INVALID_SESSION: 9,
                HELLO: 10,
                HEARTBEAT_ACK: 11
            }, t.VoiceOPCodes = {
                IDENTIFY: 0,
                SELECT_PROTOCOL: 1,
                READY: 2,
                HEARTBEAT: 3,
                SESSION_DESCRIPTION: 4,
                SPEAKING: 5,
                HELLO: 8,
                CLIENT_CONNECT: 12,
                CLIENT_DISCONNECT: 13
            }, t.Events = {
                RATE_LIMIT: "rateLimit",
                CLIENT_READY: "ready",
                GUILD_CREATE: "guildCreate",
                GUILD_DELETE: "guildDelete",
                GUILD_UPDATE: "guildUpdate",
                GUILD_UNAVAILABLE: "guildUnavailable",
                GUILD_AVAILABLE: "guildAvailable",
                GUILD_MEMBER_ADD: "guildMemberAdd",
                GUILD_MEMBER_REMOVE: "guildMemberRemove",
                GUILD_MEMBER_UPDATE: "guildMemberUpdate",
                GUILD_MEMBER_AVAILABLE: "guildMemberAvailable",
                GUILD_MEMBER_SPEAKING: "guildMemberSpeaking",
                GUILD_MEMBERS_CHUNK: "guildMembersChunk",
                GUILD_INTEGRATIONS_UPDATE: "guildIntegrationsUpdate",
                GUILD_ROLE_CREATE: "roleCreate",
                GUILD_ROLE_DELETE: "roleDelete",
                INVITE_CREATE: "inviteCreate",
                INVITE_DELETE: "inviteDelete",
                GUILD_ROLE_UPDATE: "roleUpdate",
                GUILD_EMOJI_CREATE: "emojiCreate",
                GUILD_EMOJI_DELETE: "emojiDelete",
                GUILD_EMOJI_UPDATE: "emojiUpdate",
                GUILD_BAN_ADD: "guildBanAdd",
                GUILD_BAN_REMOVE: "guildBanRemove",
                CHANNEL_CREATE: "channelCreate",
                CHANNEL_DELETE: "channelDelete",
                CHANNEL_UPDATE: "channelUpdate",
                CHANNEL_PINS_UPDATE: "channelPinsUpdate",
                MESSAGE_CREATE: "message",
                MESSAGE_DELETE: "messageDelete",
                MESSAGE_UPDATE: "messageUpdate",
                MESSAGE_BULK_DELETE: "messageDeleteBulk",
                MESSAGE_REACTION_ADD: "messageReactionAdd",
                MESSAGE_REACTION_REMOVE: "messageReactionRemove",
                MESSAGE_REACTION_REMOVE_ALL: "messageReactionRemoveAll",
                MESSAGE_REACTION_REMOVE_EMOJI: "messageReactionRemoveEmoji",
                USER_UPDATE: "userUpdate",
                PRESENCE_UPDATE: "presenceUpdate",
                VOICE_SERVER_UPDATE: "voiceServerUpdate",
                VOICE_STATE_UPDATE: "voiceStateUpdate",
                VOICE_BROADCAST_SUBSCRIBE: "subscribe",
                VOICE_BROADCAST_UNSUBSCRIBE: "unsubscribe",
                TYPING_START: "typingStart",
                TYPING_STOP: "typingStop",
                WEBHOOKS_UPDATE: "webhookUpdate",
                ERROR: "error",
                WARN: "warn",
                DEBUG: "debug",
                SHARD_DISCONNECT: "shardDisconnect",
                SHARD_ERROR: "shardError",
                SHARD_RECONNECTING: "shardReconnecting",
                SHARD_READY: "shardReady",
                SHARD_RESUME: "shardResume",
                INVALIDATED: "invalidated",
                RAW: "raw"
            }, t.ShardEvents = {
                CLOSE: "close",
                DESTROYED: "destroyed",
                INVALID_SESSION: "invalidSession",
                READY: "ready",
                RESUMED: "resumed",
                ALL_READY: "allReady"
            }, t.PartialTypes = h(["USER", "CHANNEL", "GUILD_MEMBER", "MESSAGE", "REACTION"]), t.WSEvents = h(["READY", "RESUMED", "GUILD_CREATE", "GUILD_DELETE", "GUILD_UPDATE", "INVITE_CREATE", "INVITE_DELETE", "GUILD_MEMBER_ADD", "GUILD_MEMBER_REMOVE", "GUILD_MEMBER_UPDATE", "GUILD_MEMBERS_CHUNK", "GUILD_INTEGRATIONS_UPDATE", "GUILD_ROLE_CREATE", "GUILD_ROLE_DELETE", "GUILD_ROLE_UPDATE", "GUILD_BAN_ADD", "GUILD_BAN_REMOVE", "GUILD_EMOJIS_UPDATE", "CHANNEL_CREATE", "CHANNEL_DELETE", "CHANNEL_UPDATE", "CHANNEL_PINS_UPDATE", "MESSAGE_CREATE", "MESSAGE_DELETE", "MESSAGE_UPDATE", "MESSAGE_DELETE_BULK", "MESSAGE_REACTION_ADD", "MESSAGE_REACTION_REMOVE", "MESSAGE_REACTION_REMOVE_ALL", "MESSAGE_REACTION_REMOVE_EMOJI", "USER_UPDATE", "PRESENCE_UPDATE", "TYPING_START", "VOICE_STATE_UPDATE", "VOICE_SERVER_UPDATE", "WEBHOOKS_UPDATE"]), t.MessageTypes = ["DEFAULT", "RECIPIENT_ADD", "RECIPIENT_REMOVE", "CALL", "CHANNEL_NAME_CHANGE", "CHANNEL_ICON_CHANGE", "PINS_ADD", "GUILD_MEMBER_JOIN", "USER_PREMIUM_GUILD_SUBSCRIPTION", "USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1", "USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2", "USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3", "CHANNEL_FOLLOW_ADD", null, "GUILD_DISCOVERY_DISQUALIFIED", "GUILD_DISCOVERY_REQUALIFIED"], t.ActivityTypes = ["PLAYING", "STREAMING", "LISTENING", "WATCHING", "CUSTOM_STATUS"], t.ChannelTypes = {
                TEXT: 0,
                DM: 1,
                VOICE: 2,
                GROUP: 3,
                CATEGORY: 4,
                NEWS: 5,
                STORE: 6
            }, t.ClientApplicationAssetTypes = {
                SMALL: 1,
                BIG: 2
            }, t.Colors = {
                DEFAULT: 0,
                WHITE: 16777215,
                AQUA: 1752220,
                GREEN: 3066993,
                BLUE: 3447003,
                YELLOW: 16776960,
                PURPLE: 10181046,
                LUMINOUS_VIVID_PINK: 15277667,
                GOLD: 15844367,
                ORANGE: 15105570,
                RED: 15158332,
                GREY: 9807270,
                NAVY: 3426654,
                DARK_AQUA: 1146986,
                DARK_GREEN: 2067276,
                DARK_BLUE: 2123412,
                DARK_PURPLE: 7419530,
                DARK_VIVID_PINK: 11342935,
                DARK_GOLD: 12745742,
                DARK_ORANGE: 11027200,
                DARK_RED: 10038562,
                DARK_GREY: 9936031,
                DARKER_GREY: 8359053,
                LIGHT_GREY: 12370112,
                DARK_NAVY: 2899536,
                BLURPLE: 7506394,
                GREYPLE: 10070709,
                DARK_BUT_NOT_BLACK: 2895667,
                NOT_QUITE_BLACK: 2303786
            }, t.ExplicitContentFilterLevels = ["DISABLED", "MEMBERS_WITHOUT_ROLES", "ALL_MEMBERS"], t.VerificationLevels = ["NONE", "LOW", "MEDIUM", "HIGH", "VERY_HIGH"], t.APIErrors = {
                UNKNOWN_ACCOUNT: 10001,
                UNKNOWN_APPLICATION: 10002,
                UNKNOWN_CHANNEL: 10003,
                UNKNOWN_GUILD: 10004,
                UNKNOWN_INTEGRATION: 10005,
                UNKNOWN_INVITE: 10006,
                UNKNOWN_MEMBER: 10007,
                UNKNOWN_MESSAGE: 10008,
                UNKNOWN_OVERWRITE: 10009,
                UNKNOWN_PROVIDER: 10010,
                UNKNOWN_ROLE: 10011,
                UNKNOWN_TOKEN: 10012,
                UNKNOWN_USER: 10013,
                UNKNOWN_EMOJI: 10014,
                UNKNOWN_WEBHOOK: 10015,
                BOT_PROHIBITED_ENDPOINT: 20001,
                BOT_ONLY_ENDPOINT: 20002,
                MAXIMUM_GUILDS: 30001,
                MAXIMUM_FRIENDS: 30002,
                MAXIMUM_PINS: 30003,
                MAXIMUM_ROLES: 30005,
                MAXIMUM_REACTIONS: 30010,
                MAXIMUM_CHANNELS: 30013,
                MAXIMUM_INVITES: 30016,
                UNAUTHORIZED: 40001,
                USER_BANNED: 40007,
                MISSING_ACCESS: 50001,
                INVALID_ACCOUNT_TYPE: 50002,
                CANNOT_EXECUTE_ON_DM: 50003,
                EMBED_DISABLED: 50004,
                CANNOT_EDIT_MESSAGE_BY_OTHER: 50005,
                CANNOT_SEND_EMPTY_MESSAGE: 50006,
                CANNOT_MESSAGE_USER: 50007,
                CANNOT_SEND_MESSAGES_IN_VOICE_CHANNEL: 50008,
                CHANNEL_VERIFICATION_LEVEL_TOO_HIGH: 50009,
                OAUTH2_APPLICATION_BOT_ABSENT: 50010,
                MAXIMUM_OAUTH2_APPLICATIONS: 50011,
                INVALID_OAUTH_STATE: 50012,
                MISSING_PERMISSIONS: 50013,
                INVALID_AUTHENTICATION_TOKEN: 50014,
                NOTE_TOO_LONG: 50015,
                INVALID_BULK_DELETE_QUANTITY: 50016,
                CANNOT_PIN_MESSAGE_IN_OTHER_CHANNEL: 50019,
                INVALID_OR_TAKEN_INVITE_CODE: 50020,
                CANNOT_EXECUTE_ON_SYSTEM_MESSAGE: 50021,
                INVALID_OAUTH_TOKEN: 50025,
                BULK_DELETE_MESSAGE_TOO_OLD: 50034,
                INVALID_FORM_BODY: 50035,
                INVITE_ACCEPTED_TO_GUILD_NOT_CONTAINING_BOT: 50036,
                INVALID_API_VERSION: 50041,
                REACTION_BLOCKED: 90001,
                RESOURCE_OVERLOADED: 13e4
            }, t.DefaultMessageNotifications = ["ALL", "MENTIONS"], t.MembershipStates = [null, "INVITED", "ACCEPTED"], t.WebhookTypes = [null, "Incoming", "Channel Follower"]
        }).call(this, s(23))
    }, function (e, t, s) {
        "use strict";
        const {
            PartialTypes: i
        } = s(0);
        e.exports = class GenericAction {
            constructor(e) {
                this.client = e
            }
            handle(e) {
                return e
            }
            getPayload(e, t, s, i, n) {
                const r = t.cache.get(s);
                return !r && this.client.options.partials.includes(i) ? t.add(e, n) : r
            }
            getChannel(e) {
                const t = e.channel_id || e.id;
                return e.channel || this.getPayload({
                    id: t,
                    guild_id: e.guild_id,
                    recipients: [e.author || {
                        id: e.user_id
                    }]
                }, this.client.channels, t, i.CHANNEL)
            }
            getMessage(e, t, s) {
                const n = e.message_id || e.id;
                return e.message || this.getPayload({
                    id: n,
                    channel_id: t.id,
                    guild_id: e.guild_id || (t.guild ? t.guild.id : null)
                }, t.messages, n, i.MESSAGE, s)
            }
            getReaction(e, t, s) {
                const n = e.emoji.id || decodeURIComponent(e.emoji.name);
                return this.getPayload({
                    emoji: e.emoji,
                    count: t.partial ? null : 0,
                    me: !!s && s.id === this.client.user.id
                }, t.reactions, n, i.REACTION)
            }
            getMember(e, t) {
                const s = e.user.id;
                return this.getPayload({
                    user: {
                        id: s
                    }
                }, t.members, s, i.GUILD_MEMBER)
            }
            getUser(e) {
                const t = e.user_id;
                return e.user || this.getPayload({
                    id: t
                }, this.client.users, t, i.USER)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(85),
            n = s(4);
        e.exports = class Collection extends i {
            toJSON() {
                return this.map(e => "function" == typeof e.toJSON ? e.toJSON() : n.flatten(e))
            }
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = s(50), e.exports.Messages = s(84)
    }, function (e, t, s) {
        "use strict";
        const {
            parse: i
        } = s(29), n = s(30), {
            Colors: r,
            DefaultOptions: o,
            Endpoints: a
        } = s(0), {
            Error: c,
            RangeError: l,
            TypeError: h
        } = s(3), u = e => "object" == typeof e && null !== e;
        class Util {
            constructor() {
                throw new Error(`The ${this.constructor.name} class may not be instantiated.`)
            }
            static flatten(e, ...t) {
                if (!u(e)) return e;
                t = Object.assign(...Object.keys(e).filter(e => !e.startsWith("_")).map(e => ({
                    [e]: !0
                })), ...t);
                const i = {};
                for (let [n, r] of Object.entries(t)) {
                    if (!r) continue;
                    r = !0 === r ? n : r;
                    const t = e[n],
                        o = u(t),
                        a = o && "function" == typeof t.valueOf ? t.valueOf() : null;
                    t instanceof s(2) ? i[r] = Array.from(t.keys()) : a instanceof s(2) ? i[r] = Array.from(a.keys()) : Array.isArray(t) ? i[r] = t.map(e => Util.flatten(e)) : "object" != typeof a ? i[r] = a : o || (i[r] = t)
                }
                return i
            }
            static splitMessage(e, {
                maxLength: t = 2e3,
                char: s = "\n",
                prepend: i = "",
                append: n = ""
            } = {}) {
                if ((e = Util.resolveString(e)).length <= t) return [e];
                const r = e.split(s);
                if (r.some(e => e.length > t)) throw new l("SPLIT_MAX_LEN");
                const o = [];
                let a = "";
                for (const e of r) a && (a + s + e + n).length > t && (o.push(a + n), a = i), a += (a && a !== i ? s : "") + e;
                return o.concat(a).filter(e => e)
            }
            static escapeMarkdown(e, {
                codeBlock: t = !0,
                inlineCode: s = !0,
                bold: i = !0,
                italic: n = !0,
                underline: r = !0,
                strikethrough: o = !0,
                spoiler: a = !0,
                codeBlockContent: c = !0,
                inlineCodeContent: l = !0
            } = {}) {
                return c ? l ? (s && (e = Util.escapeInlineCode(e)), t && (e = Util.escapeCodeBlock(e)), n && (e = Util.escapeItalic(e)), i && (e = Util.escapeBold(e)), r && (e = Util.escapeUnderline(e)), o && (e = Util.escapeStrikethrough(e)), a && (e = Util.escapeSpoiler(e)), e) : e.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((e, s, c) => s % 2 && s !== c.length - 1 ? e : Util.escapeMarkdown(e, {
                    codeBlock: t,
                    bold: i,
                    italic: n,
                    underline: r,
                    strikethrough: o,
                    spoiler: a
                })).join(s ? "\\`" : "`") : e.split("```").map((e, t, c) => t % 2 && t !== c.length - 1 ? e : Util.escapeMarkdown(e, {
                    inlineCode: s,
                    bold: i,
                    italic: n,
                    underline: r,
                    strikethrough: o,
                    spoiler: a,
                    inlineCodeContent: l
                })).join(t ? "\\`\\`\\`" : "```")
            }
            static escapeCodeBlock(e) {
                return e.replace(/```/g, "\\`\\`\\`")
            }
            static escapeInlineCode(e) {
                return e.replace(/(?<=^|[^`])`(?=[^`]|$)/g, "\\`")
            }
            static escapeItalic(e) {
                let t = 0;
                return e = e.replace(/(?<=^|[^*])\*([^*]|\*\*|$)/g, (e, s) => "**" === s ? ++t % 2 ? `\\*${s}` : `${s}\\*` : `\\*${s}`), t = 0, e.replace(/(?<=^|[^_])_([^_]|__|$)/g, (e, s) => "__" === s ? ++t % 2 ? `\\_${s}` : `${s}\\_` : `\\_${s}`)
            }
            static escapeBold(e) {
                let t = 0;
                return e.replace(/\*\*(\*)?/g, (e, s) => s ? ++t % 2 ? `${s}\\*\\*` : `\\*\\*${s}` : "\\*\\*")
            }
            static escapeUnderline(e) {
                let t = 0;
                return e.replace(/__(_)?/g, (e, s) => s ? ++t % 2 ? `${s}\\_\\_` : `\\_\\_${s}` : "\\_\\_")
            }
            static escapeStrikethrough(e) {
                return e.replace(/~~/g, "\\~\\~")
            }
            static escapeSpoiler(e) {
                return e.replace(/\|\|/g, "\\|\\|")
            }
            static fetchRecommendedShards(e, t = 1e3) {
                if (!e) throw new c("TOKEN_MISSING");
                return n(`${o.http.api}/v${o.http.version}${a.botGateway}`, {
                    method: "GET",
                    headers: {
                        Authorization: `Bot ${e.replace(/^Bot\s*/i,"")}`
                    }
                }).then(e => {
                    if (e.ok) return e.json();
                    throw e
                }).then(e => e.shards * (1e3 / t))
            }
            static parseEmoji(e) {
                if (e.includes("%") && (e = decodeURIComponent(e)), !e.includes(":")) return {
                    animated: !1,
                    name: e,
                    id: null
                };
                const t = e.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
                return t ? {
                    animated: Boolean(t[1]),
                    name: t[2],
                    id: t[3] || null
                } : null
            }
            static cloneObject(e) {
                return Object.assign(Object.create(e), e)
            }
            static mergeDefault(e, t) {
                if (!t) return e;
                for (const n in e) s = t, i = n, Object.prototype.hasOwnProperty.call(s, i) && void 0 !== t[n] ? t[n] === Object(t[n]) && (t[n] = Util.mergeDefault(e[n], t[n])) : t[n] = e[n];
                var s, i;
                return t
            }
            static convertToBuffer(e) {
                return "string" == typeof e && (e = Util.str2ab(e)), Buffer.from(e)
            }
            static str2ab(e) {
                const t = new ArrayBuffer(2 * e.length),
                    s = new Uint16Array(t);
                for (var i = 0, n = e.length; i < n; i++) s[i] = e.charCodeAt(i);
                return t
            }
            static makeError(e) {
                const t = new Error(e.message);
                return t.name = e.name, t.stack = e.stack, t
            }
            static makePlainError(e) {
                return {
                    name: e.name,
                    message: e.message,
                    stack: e.stack
                }
            }
            static moveElementInArray(e, t, s, i = !1) {
                const n = e.indexOf(t);
                if ((s = (i ? n : 0) + s) > -1 && s < e.length) {
                    const t = e.splice(n, 1)[0];
                    e.splice(s, 0, t)
                }
                return e.indexOf(t)
            }
            static resolveString(e) {
                return "string" == typeof e ? e : Array.isArray(e) ? e.join("\n") : String(e)
            }
            static resolveColor(e) {
                if ("string" == typeof e) {
                    if ("RANDOM" === e) return Math.floor(16777216 * Math.random());
                    if ("DEFAULT" === e) return 0;
                    e = r[e] || parseInt(e.replace("#", ""), 16)
                } else Array.isArray(e) && (e = (e[0] << 16) + (e[1] << 8) + e[2]);
                if (e < 0 || e > 16777215) throw new l("COLOR_RANGE");
                if (e && isNaN(e)) throw new h("COLOR_CONVERT");
                return e
            }
            static discordSort(e) {
                return e.sorted((e, t) => e.rawPosition - t.rawPosition || parseInt(t.id.slice(0, -10)) - parseInt(e.id.slice(0, -10)) || parseInt(t.id.slice(10)) - parseInt(e.id.slice(10)))
            }
            static setPosition(e, t, s, i, n, r) {
                let o = i.array();
                return Util.moveElementInArray(o, e, t, s), o = o.map((e, t) => ({
                    id: e.id,
                    position: t
                })), n.patch({
                    data: o,
                    reason: r
                }).then(() => o)
            }
            static basename(e, t) {
                let s = i(e);
                return t && s.ext.startsWith(t) ? s.name : s.base.split("?")[0]
            }
            static idToBinary(e) {
                let t = "",
                    s = parseInt(e.slice(0, -10)) || 0,
                    i = parseInt(e.slice(-10));
                for (; i > 0 || s > 0;) t = String(1 & i) + t, i = Math.floor(i / 2), s > 0 && (i += s % 2 * 5e9, s = Math.floor(s / 2));
                return t
            }
            static binaryToID(e) {
                let t = "";
                for (; e.length > 50;) {
                    const s = parseInt(e.slice(0, -32), 2),
                        i = parseInt((s % 10).toString(2) + e.slice(-32), 2);
                    t = (i % 10).toString() + t, e = Math.floor(s / 10).toString(2) + Math.floor(i / 10).toString(2).padStart(32, "0")
                }
                for (e = parseInt(e, 2); e > 0;) t = (e % 10).toString() + t, e = Math.floor(e / 10);
                return t
            }
            static removeMentions(e) {
                return e.replace(/@/g, "@​")
            }
            static cleanContent(e, t) {
                return e = e.replace(/<@!?[0-9]+>/g, e => {
                    const s = e.replace(/<|!|>|@/g, "");
                    if ("dm" === t.channel.type) {
                        const i = t.client.users.cache.get(s);
                        return i ? `@${i.username}` : e
                    }
                    const i = t.channel.guild.members.cache.get(s);
                    if (i) return `@${i.displayName}`; {
                        const i = t.client.users.cache.get(s);
                        return i ? `@${i.username}` : e
                    }
                }).replace(/<#[0-9]+>/g, e => {
                    const s = t.client.channels.cache.get(e.replace(/<|#|>/g, ""));
                    return s ? `#${s.name}` : e
                }).replace(/<@&[0-9]+>/g, e => {
                    if ("dm" === t.channel.type) return e;
                    const s = t.guild.roles.cache.get(e.replace(/<|@|>|&/g, ""));
                    return s ? `@${s.name}` : e
                }), "everyone" === t.client.options.disableMentions && (e = e.replace(/@([^<>@ ]*)/gmus, (e, t) => t.match(/^[&!]?\d+$/) ? `@${t}` : `@​${t}`)), "all" === t.client.options.disableMentions ? Util.removeMentions(e) : e
            }
            static cleanCodeBlockContent(e) {
                return e.replace(/```/g, "`​``")
            }
            static delayFor(e) {
                return new Promise(t => {
                    setTimeout(t, e)
                })
            }
        }
        e.exports = Util
    }, function (e, t, s) {
        "use strict";
        const i = s(4);
        e.exports = class Base {
            constructor(e) {
                Object.defineProperty(this, "client", {
                    value: e
                })
            }
            _clone() {
                return Object.assign(Object.create(this), this)
            }
            _patch(e) {
                return e
            }
            _update(e) {
                const t = this._clone();
                return this._patch(e), t
            }
            toJSON(...e) {
                return i.flatten(this, ...e)
            }
            valueOf() {
                return this.id
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(2);
        let n;
        e.exports = class BaseManager {
            constructor(e, t, r, o = i, ...a) {
                if (n || (n = s(18)), Object.defineProperty(this, "holds", {
                        value: n.get(r.name) || r
                    }), Object.defineProperty(this, "client", {
                        value: e
                    }), this.cacheType = o, this.cache = new o(...a), t)
                    for (const e of t) this.add(e)
            }
            add(e, t = !0, {
                id: s,
                extras: i = []
            } = {}) {
                const n = this.cache.get(s || e.id);
                if (n && n._patch && t && n._patch(e), n) return n;
                const r = this.holds ? new this.holds(this.client, e, ...i) : e;
                return t && this.cache.set(s || r.id, r), r
            }
            resolve(e) {
                return e instanceof this.holds ? e : "string" == typeof e && this.cache.get(e) || null
            }
            resolveID(e) {
                return e instanceof this.holds ? e.id : "string" == typeof e ? e : null
            }
            valueOf() {
                return this.cache
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(4);
        let n = 0;
        e.exports = class SnowflakeUtil {
            constructor() {
                throw new Error(`The ${this.constructor.name} class may not be instantiated.`)
            }
            static generate(e = Date.now()) {
                if (e instanceof Date && (e = e.getTime()), "number" != typeof e || isNaN(e)) throw new TypeError(`"timestamp" argument must be a number (received ${isNaN(e)?"NaN":typeof e})`);
                n >= 4095 && (n = 0);
                const t = `${(e-14200704e5).toString(2).padStart(42,"0")}0000100000${(n++).toString(2).padStart(12,"0")}`;
                return i.binaryToID(t)
            }
            static deconstruct(e) {
                const t = i.idToBinary(e).toString(2).padStart(64, "0"),
                    s = {
                        timestamp: parseInt(t.substring(0, 42), 2) + 14200704e5,
                        workerID: parseInt(t.substring(42, 47), 2),
                        processID: parseInt(t.substring(47, 52), 2),
                        increment: parseInt(t.substring(52, 64), 2),
                        binary: t
                    };
                return Object.defineProperty(s, "date", {
                    get: function () {
                        return new Date(this.timestamp)
                    },
                    enumerable: !0
                }), s
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(14);
        class Permissions extends i {
            any(e, t = !0) {
                return t && super.has(this.constructor.FLAGS.ADMINISTRATOR) || super.any(e)
            }
            has(e, t = !0) {
                return t && super.has(this.constructor.FLAGS.ADMINISTRATOR) || super.has(e)
            }
        }
        Permissions.FLAGS = {
            CREATE_INSTANT_INVITE: 1,
            KICK_MEMBERS: 2,
            BAN_MEMBERS: 4,
            ADMINISTRATOR: 8,
            MANAGE_CHANNELS: 16,
            MANAGE_GUILD: 32,
            ADD_REACTIONS: 64,
            VIEW_AUDIT_LOG: 128,
            PRIORITY_SPEAKER: 256,
            STREAM: 512,
            VIEW_CHANNEL: 1024,
            SEND_MESSAGES: 2048,
            SEND_TTS_MESSAGES: 4096,
            MANAGE_MESSAGES: 8192,
            EMBED_LINKS: 16384,
            ATTACH_FILES: 32768,
            READ_MESSAGE_HISTORY: 65536,
            MENTION_EVERYONE: 1 << 17,
            USE_EXTERNAL_EMOJIS: 1 << 18,
            VIEW_GUILD_INSIGHTS: 1 << 19,
            CONNECT: 1 << 20,
            SPEAK: 1 << 21,
            MUTE_MEMBERS: 1 << 22,
            DEAFEN_MEMBERS: 1 << 23,
            MOVE_MEMBERS: 1 << 24,
            USE_VAD: 1 << 25,
            CHANGE_NICKNAME: 1 << 26,
            MANAGE_NICKNAMES: 1 << 27,
            MANAGE_ROLES: 1 << 28,
            MANAGE_WEBHOOKS: 1 << 29,
            MANAGE_EMOJIS: 1 << 30
        }, Permissions.ALL = Object.values(Permissions.FLAGS).reduce((e, t) => e | t, 0), Permissions.DEFAULT = 104324673, e.exports = Permissions
    }, function (e, t, s) {
        "use strict";
        const i = s(29),
            n = s(29),
            r = s(30),
            {
                Error: o,
                TypeError: a
            } = s(3),
            {
                browser: c
            } = s(0),
            l = s(4);
        class DataResolver {
            constructor() {
                throw new Error(`The ${this.constructor.name} class may not be instantiated.`)
            }
            static resolveInviteCode(e) {
                const t = /discord(?:app\.com\/invite|\.gg(?:\/invite)?)\/([\w-]{2,255})/i.exec(e);
                return t && t[1] ? t[1] : e
            }
            static async resolveImage(e) {
                if (!e) return null;
                if ("string" == typeof e && e.startsWith("data:")) return e;
                const t = await this.resolveFile(e);
                return DataResolver.resolveBase64(t)
            }
            static resolveBase64(e) {
                return Buffer.isBuffer(e) ? `data:image/jpg;base64,${e.toString("base64")}` : e
            }
            static resolveFile(e) {
                if (!c && Buffer.isBuffer(e)) return Promise.resolve(e);
                if (c && e instanceof ArrayBuffer) return Promise.resolve(l.convertToBuffer(e));
                if ("string" == typeof e) {
                    if (/^https?:\/\//.test(e)) return r(e).then(e => c ? e.blob() : e.buffer());
                    if (!c) return new Promise((t, s) => {
                        const r = c ? e : n.resolve(e);
                        i.stat(r, (e, n) => e ? s(e) : n.isFile() ? (i.readFile(r, (e, i) => {
                            e ? s(e) : t(i)
                        }), null) : s(new o("FILE_NOT_FOUND", r)))
                    })
                } else if ("function" == typeof e.pipe) return new Promise((t, s) => {
                    const i = [];
                    e.once("error", s), e.on("data", e => i.push(e)), e.once("end", () => t(Buffer.concat(i)))
                });
                return Promise.reject(new a("REQ_RESOURCE_TYPE"))
            }
        }
        e.exports = DataResolver
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            {
                Presence: n
            } = s(12),
            r = s(17),
            o = s(21),
            a = s(27),
            {
                Error: c
            } = s(3),
            l = s(59),
            h = s(8);
        class GuildMember extends i {
            constructor(e, t, s) {
                super(e), this.guild = s, t.user && (this.user = e.users.add(t.user, !0)), this.joinedTimestamp = null, this.lastMessageID = null, this.lastMessageChannelID = null, this.premiumSinceTimestamp = null, this.deleted = !1, this._roles = [], t && this._patch(t)
            }
            _patch(e) {
                void 0 !== e.nick && (this.nickname = e.nick), e.joined_at && (this.joinedTimestamp = new Date(e.joined_at).getTime()), e.premium_since && (this.premiumSinceTimestamp = new Date(e.premium_since).getTime()), e.user && (this.user = this.guild.client.users.add(e.user)), e.roles && (this._roles = e.roles)
            }
            _clone() {
                const e = super._clone();
                return e._roles = this._roles.slice(), e
            }
            get partial() {
                return !this.joinedTimestamp
            }
            get roles() {
                return new l(this)
            }
            get lastMessage() {
                const e = this.guild.channels.cache.get(this.lastMessageChannelID);
                return e && e.messages.cache.get(this.lastMessageID) || null
            }
            get voice() {
                return this.guild.voiceStates.cache.get(this.id) || new o(this.guild, {
                    user_id: this.id
                })
            }
            get joinedAt() {
                return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null
            }
            get premiumSince() {
                return this.premiumSinceTimestamp ? new Date(this.premiumSinceTimestamp) : null
            }
            get presence() {
                return this.guild.presences.cache.get(this.id) || new n(this.client, {
                    user: {
                        id: this.id
                    },
                    guild: this.guild
                })
            }
            get displayColor() {
                const e = this.roles.color;
                return e && e.color || 0
            }
            get displayHexColor() {
                const e = this.roles.color;
                return e && e.hexColor || "#000000"
            }
            get id() {
                return this.user.id
            }
            get displayName() {
                return this.nickname || this.user.username
            }
            get permissions() {
                return this.user.id === this.guild.ownerID ? new h(h.ALL).freeze() : new h(this.roles.cache.map(e => e.permissions)).freeze()
            }
            get manageable() {
                if (this.user.id === this.guild.ownerID) return !1;
                if (this.user.id === this.client.user.id) return !1;
                if (this.client.user.id === this.guild.ownerID) return !0;
                if (!this.guild.me) throw new c("GUILD_UNCACHED_ME");
                return this.guild.me.roles.highest.comparePositionTo(this.roles.highest) > 0
            }
            get kickable() {
                return this.manageable && this.guild.me.permissions.has(h.FLAGS.KICK_MEMBERS)
            }
            get bannable() {
                return this.manageable && this.guild.me.permissions.has(h.FLAGS.BAN_MEMBERS)
            }
            permissionsIn(e) {
                if (!(e = this.guild.channels.resolve(e))) throw new c("GUILD_CHANNEL_RESOLVE");
                return e.memberPermissions(this)
            }
            hasPermission(e, {
                checkAdmin: t = !0,
                checkOwner: s = !0
            } = {}) {
                return !(!s || this.user.id !== this.guild.ownerID) || this.roles.cache.some(s => s.permissions.has(e, t))
            }
            async edit(e, t) {
                if (e.channel) {
                    if (e.channel = this.guild.channels.resolve(e.channel), !e.channel || "voice" !== e.channel.type) throw new c("GUILD_VOICE_CHANNEL_RESOLVE");
                    e.channel_id = e.channel.id, e.channel = void 0
                } else null === e.channel && (e.channel_id = null, e.channel = void 0);
                e.roles && (e.roles = e.roles.map(e => e instanceof r ? e.id : e));
                let s = this.client.api.guilds(this.guild.id);
                if (this.user.id === this.client.user.id) {
                    const t = Object.keys(e);
                    s = 1 === t.length && "nick" === t[0] ? s.members("@me").nick : s.members(this.id)
                } else s = s.members(this.id);
                await s.patch({
                    data: e,
                    reason: t
                });
                const i = this._clone();
                return e.user = this.user, i._patch(e), i
            }
            setNickname(e, t) {
                return this.edit({
                    nick: e
                }, t)
            }
            createDM() {
                return this.user.createDM()
            }
            deleteDM() {
                return this.user.deleteDM()
            }
            kick(e) {
                return this.client.api.guilds(this.guild.id).members(this.user.id).delete({
                    reason: e
                }).then(() => this)
            }
            ban(e) {
                return this.guild.members.ban(this, e)
            }
            fetch() {
                return this.guild.members.fetch(this.id, !0)
            }
            toString() {
                return `<@${this.nickname?"!":""}${this.user.id}>`
            }
            toJSON() {
                return super.toJSON({
                    guild: "guildID",
                    user: "userID",
                    displayName: !0,
                    speaking: !1,
                    lastMessage: !1,
                    lastMessageID: !1,
                    roles: !0
                })
            }
            send() {}
        }
        a.applyToClass(GuildMember), e.exports = GuildMember
    }, function (e, t, s) {
        "use strict";
        const i = s(26),
            n = s(13),
            {
                WebhookTypes: r
            } = s(0),
            o = s(9),
            a = s(7);
        class Webhook {
            constructor(e, t) {
                Object.defineProperty(this, "client", {
                    value: e
                }), t && this._patch(t)
            }
            _patch(e) {
                this.name = e.name, Object.defineProperty(this, "token", {
                    value: e.token || null,
                    writable: !0,
                    configurable: !0
                }), this.avatar = e.avatar, this.id = e.id, this.type = r[e.type], this.guildID = e.guild_id, this.channelID = e.channel_id, e.user ? this.owner = this.client.users ? this.client.users.cache.get(e.user.id) : e.user : this.owner = null
            }
            async send(e, t) {
                let s;
                if (e instanceof i) s = e.resolveData();
                else if (s = i.create(this, e, t).resolveData(), Array.isArray(s.data.content)) return Promise.all(s.split().map(this.send.bind(this)));
                const {
                    data: n,
                    files: r
                } = await s.resolveFiles();
                return this.client.api.webhooks(this.id, this.token).post({
                    data: n,
                    files: r,
                    query: {
                        wait: !0
                    },
                    auth: !1
                }).then(e => {
                    const t = this.client.channels ? this.client.channels.cache.get(e.channel_id) : void 0;
                    return t ? t.messages.add(e, !1) : e
                })
            }
            sendSlackMessage(e) {
                return this.client.api.webhooks(this.id, this.token).slack.post({
                    query: {
                        wait: !0
                    },
                    auth: !1,
                    data: e
                }).then(e => "ok" === e.toString())
            }
            async edit({
                name: e = this.name,
                avatar: t,
                channel: s
            }, i) {
                t && "string" == typeof t && !t.startsWith("data:") && (t = await o.resolveImage(t)), s && (s = s instanceof n ? s.id : s);
                const r = await this.client.api.webhooks(this.id, s ? void 0 : this.token).patch({
                    data: {
                        name: e,
                        avatar: t,
                        channel_id: s
                    },
                    reason: i
                });
                return this.name = r.name, this.avatar = r.avatar, this.channelID = r.channel_id, this
            }
            delete(e) {
                return this.client.api.webhooks(this.id, this.token).delete({
                    reason: e
                })
            }
            get createdTimestamp() {
                return a.deconstruct(this.id).timestamp
            }
            get createdAt() {
                return new Date(this.createdTimestamp)
            }
            get url() {
                return this.client.options.http.api + this.client.api.webhooks(this.id, this.token)
            }
            avatarURL({
                format: e,
                size: t
            } = {}) {
                return this.avatar ? this.client.rest.cdn.Avatar(this.id, this.avatar, e, t) : null
            }
            static applyToClass(e) {
                for (const t of ["send", "sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt", "url"]) Object.defineProperty(e.prototype, t, Object.getOwnPropertyDescriptor(Webhook.prototype, t))
            }
        }
        e.exports = Webhook
    }, function (e, t, s) {
        "use strict";
        const i = s(25),
            n = s(57),
            {
                ActivityTypes: r
            } = s(0),
            o = s(4);
        class Activity {
            constructor(e, t) {
                Object.defineProperty(this, "presence", {
                    value: e
                }), this.name = t.name, this.type = r[t.type], this.url = t.url || null, this.details = t.details || null, this.state = t.state || null, this.applicationID = t.application_id || null, this.timestamps = t.timestamps ? {
                    start: t.timestamps.start ? new Date(Number(t.timestamps.start)) : null,
                    end: t.timestamps.end ? new Date(Number(t.timestamps.end)) : null
                } : null, this.party = t.party || null, this.assets = t.assets ? new RichPresenceAssets(this, t.assets) : null, this.syncID = t.sync_id, this.flags = new n(t.flags).freeze(), this.emoji = t.emoji ? new i(e.client, t.emoji) : null, this.createdTimestamp = new Date(t.created_at).getTime()
            }
            equals(e) {
                return this === e || e && this.name === e.name && this.type === e.type && this.url === e.url
            }
            get createdAt() {
                return new Date(this.createdTimestamp)
            }
            toString() {
                return this.name
            }
            _clone() {
                return Object.assign(Object.create(this), this)
            }
        }
        class RichPresenceAssets {
            constructor(e, t) {
                Object.defineProperty(this, "activity", {
                    value: e
                }), this.largeText = t.large_text || null, this.smallText = t.small_text || null, this.largeImage = t.large_image || null, this.smallImage = t.small_image || null
            }
            smallImageURL({
                format: e,
                size: t
            } = {}) {
                return this.smallImage ? this.activity.presence.client.rest.cdn.AppAsset(this.activity.applicationID, this.smallImage, {
                    format: e,
                    size: t
                }) : null
            }
            largeImageURL({
                format: e,
                size: t
            } = {}) {
                return this.largeImage ? /^spotify:/.test(this.largeImage) ? `https://i.scdn.co/image/${this.largeImage.slice(8)}` : /^twitch:/.test(this.largeImage) ? `https://static-cdn.jtvnw.net/previews-ttv/live_user_${this.largeImage.slice(7)}.png` : this.activity.presence.client.rest.cdn.AppAsset(this.activity.applicationID, this.largeImage, {
                    format: e,
                    size: t
                }) : null
            }
        }
        t.Presence = class Presence {
            constructor(e, t = {}) {
                Object.defineProperty(this, "client", {
                    value: e
                }), this.userID = t.user.id, this.guild = t.guild || null, this.patch(t)
            }
            get user() {
                return this.client.users.cache.get(this.userID) || null
            }
            get member() {
                return this.guild.members.cache.get(this.userID) || null
            }
            patch(e) {
                return this.status = e.status || this.status || "offline", e.activities ? this.activities = e.activities.map(e => new Activity(this, e)) : e.activity || e.game ? this.activities = [new Activity(this, e.game || e.activity)] : this.activities = [], this.clientStatus = e.client_status || null, this
            }
            _clone() {
                const e = Object.assign(Object.create(this), this);
                return this.activities && (e.activities = this.activities.map(e => e._clone())), e
            }
            equals(e) {
                return this === e || e && this.status === e.status && this.activities.length === e.activities.length && this.activities.every((t, s) => t.equals(e.activities[s])) && this.clientStatus.web === e.clientStatus.web && this.clientStatus.mobile === e.clientStatus.mobile && this.clientStatus.desktop === e.clientStatus.desktop
            }
            toJSON() {
                return o.flatten(this)
            }
        }, t.Activity = Activity, t.RichPresenceAssets = RichPresenceAssets
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            {
                ChannelTypes: n
            } = s(0),
            r = s(7);
        e.exports = class Channel extends i {
            constructor(e, t) {
                super(e);
                const s = Object.keys(n)[t.type];
                this.type = s ? s.toLowerCase() : "unknown", this.deleted = !1, t && this._patch(t)
            }
            _patch(e) {
                this.id = e.id
            }
            get createdTimestamp() {
                return r.deconstruct(this.id).timestamp
            }
            get createdAt() {
                return new Date(this.createdTimestamp)
            }
            toString() {
                return `<#${this.id}>`
            }
            delete() {
                return this.client.api.channels(this.id).delete().then(() => this)
            }
            fetch() {
                return this.client.channels.fetch(this.id, !0)
            }
            static create(e, t, i) {
                const r = s(18);
                let o;
                if (t.guild_id || i) {
                    if (i = i || e.guilds.cache.get(t.guild_id)) {
                        switch (t.type) {
                            case n.TEXT:
                                o = new(r.get("TextChannel"))(i, t);
                                break;
                            case n.VOICE:
                                o = new(r.get("VoiceChannel"))(i, t);
                                break;
                            case n.CATEGORY:
                                o = new(r.get("CategoryChannel"))(i, t);
                                break;
                            case n.NEWS:
                                o = new(r.get("NewsChannel"))(i, t);
                                break;
                            case n.STORE:
                                o = new(r.get("StoreChannel"))(i, t);
                                break
                        }
                        o && i.channels.cache.set(o.id, o)
                    }
                } else if (t.recipients && t.type !== n.GROUP || t.type === n.DM) {
                    o = new(r.get("DMChannel"))(e, t)
                } else if (t.type === n.GROUP) {
                    o = new(s(109))(e, t)
                }
                return o
            }
            toJSON(...e) {
                return super.toJSON({
                    createdTimestamp: !0
                }, ...e)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const {
            RangeError: i
        } = s(3);
        class BitField {
            constructor(e) {
                this.bitfield = this.constructor.resolve(e)
            }
            any(e) {
                return 0 != (this.bitfield & this.constructor.resolve(e))
            }
            equals(e) {
                return this.bitfield === this.constructor.resolve(e)
            }
            has(e) {
                return Array.isArray(e) ? e.every(e => this.has(e)) : (e = this.constructor.resolve(e), (this.bitfield & e) === e)
            }
            missing(e, ...t) {
                return Array.isArray(e) || (e = new this.constructor(e).toArray(!1)), e.filter(e => !this.has(e, ...t))
            }
            freeze() {
                return Object.freeze(this)
            }
            add(...e) {
                let t = 0;
                for (const s of e) t |= this.constructor.resolve(s);
                return Object.isFrozen(this) ? new this.constructor(this.bitfield | t) : (this.bitfield |= t, this)
            }
            remove(...e) {
                let t = 0;
                for (const s of e) t |= this.constructor.resolve(s);
                return Object.isFrozen(this) ? new this.constructor(this.bitfield & ~t) : (this.bitfield &= ~t, this)
            }
            serialize(...e) {
                const t = {};
                for (const [s, i] of Object.entries(this.constructor.FLAGS)) t[s] = this.has(i, ...e);
                return t
            }
            toArray(...e) {
                return Object.keys(this.constructor.FLAGS).filter(t => this.has(t, ...e))
            }
            toJSON() {
                return this.bitfield
            }
            valueOf() {
                return this.bitfield
            }*[Symbol.iterator]() {
                yield* this.toArray()
            }
            static resolve(e = 0) {
                if ("number" == typeof e && e >= 0) return e;
                if (e instanceof BitField) return e.bitfield;
                if (Array.isArray(e)) return e.map(e => this.resolve(e)).reduce((e, t) => e | t, 0);
                if ("string" == typeof e && void 0 !== this.FLAGS[e]) return this.FLAGS[e];
                throw new i("BITFIELD_INVALID")
            }
        }
        BitField.FLAGS = {}, e.exports = BitField
    }, function (e, t, s) {
        "use strict";
        const i = s(13),
            n = s(16),
            r = s(35),
            o = s(17),
            {
                Error: a,
                TypeError: c
            } = s(3),
            l = s(2),
            h = s(8),
            u = s(4);
        e.exports = class GuildChannel extends i {
            constructor(e, t) {
                super(e.client, t), this.guild = e
            }
            _patch(e) {
                if (super._patch(e), this.name = e.name, this.rawPosition = e.position, this.parentID = e.parent_id, this.permissionOverwrites = new l, e.permission_overwrites)
                    for (const t of e.permission_overwrites) this.permissionOverwrites.set(t.id, new r(this, t))
            }
            get parent() {
                return this.guild.channels.cache.get(this.parentID) || null
            }
            get permissionsLocked() {
                return this.parent ? this.permissionOverwrites.size === this.parent.permissionOverwrites.size && this.permissionOverwrites.every((e, t) => {
                    const s = this.parent.permissionOverwrites.get(t);
                    return void 0 !== s && s.deny.bitfield === e.deny.bitfield && s.allow.bitfield === e.allow.bitfield
                }) : null
            }
            get position() {
                const e = this.guild._sortedChannels(this);
                return e.array().indexOf(e.get(this.id))
            }
            permissionsFor(e) {
                const t = this.guild.members.resolve(e);
                if (t) return this.memberPermissions(t);
                const s = this.guild.roles.resolve(e);
                return s ? this.rolePermissions(s) : null
            }
            overwritesFor(e, t = !1, s = null) {
                if (t || (e = this.guild.members.resolve(e)), !e) return [];
                s = s || e.roles.cache;
                const i = [];
                let n, r;
                for (const t of this.permissionOverwrites.values()) t.id === this.guild.id ? r = t : s.has(t.id) ? i.push(t) : t.id === e.id && (n = t);
                return {
                    everyone: r,
                    roles: i,
                    member: n
                }
            }
            memberPermissions(e) {
                if (e.id === this.guild.ownerID) return new h(h.ALL).freeze();
                const t = e.roles.cache,
                    s = new h(t.map(e => e.permissions));
                if (s.has(h.FLAGS.ADMINISTRATOR)) return new h(h.ALL).freeze();
                const i = this.overwritesFor(e, !0, t);
                return s.remove(i.everyone ? i.everyone.deny : 0).add(i.everyone ? i.everyone.allow : 0).remove(i.roles.length > 0 ? i.roles.map(e => e.deny) : 0).add(i.roles.length > 0 ? i.roles.map(e => e.allow) : 0).remove(i.member ? i.member.deny : 0).add(i.member ? i.member.allow : 0).freeze()
            }
            rolePermissions(e) {
                if (e.permissions.has(h.FLAGS.ADMINISTRATOR)) return new h(h.ALL).freeze();
                const t = this.permissionOverwrites.get(this.guild.id),
                    s = this.permissionOverwrites.get(e.id);
                return e.permissions.remove(t ? t.deny : 0).add(t ? t.allow : 0).remove(s ? s.deny : 0).add(s ? s.allow : 0).freeze()
            }
            overwritePermissions(e, t) {
                return Array.isArray(e) || e instanceof l ? this.edit({
                    permissionOverwrites: e,
                    reason: t
                }).then(() => this) : Promise.reject(new c("INVALID_TYPE", "overwrites", "Array or Collection of Permission Overwrites", !0))
            }
            updateOverwrite(e, t, s) {
                if (!(e = this.guild.roles.resolve(e) || this.client.users.resolve(e))) return Promise.reject(new c("INVALID_TYPE", "parameter", "User nor a Role", !0));
                const i = this.permissionOverwrites.get(e.id);
                return i ? i.update(t, s).then(() => this) : this.createOverwrite(e, t, s)
            }
            createOverwrite(e, t, s) {
                if (!(e = this.guild.roles.resolve(e) || this.client.users.resolve(e))) return Promise.reject(new c("INVALID_TYPE", "parameter", "User nor a Role", !0));
                const i = e instanceof o ? "role" : "member",
                    {
                        allow: n,
                        deny: a
                    } = r.resolveOverwriteOptions(t);
                return this.client.api.channels(this.id).permissions[e.id].put({
                    data: {
                        id: e.id,
                        type: i,
                        allow: n.bitfield,
                        deny: a.bitfield
                    },
                    reason: s
                }).then(() => this)
            }
            lockPermissions() {
                if (!this.parent) return Promise.reject(new a("GUILD_CHANNEL_ORPHAN"));
                const e = this.parent.permissionOverwrites.map(e => e.toJSON());
                return this.edit({
                    permissionOverwrites: e
                })
            }
            get members() {
                const e = new l;
                for (const t of this.guild.members.cache.values()) this.permissionsFor(t).has("VIEW_CHANNEL", !1) && e.set(t.id, t);
                return e
            }
            async edit(e, t) {
                void 0 !== e.position && await u.setPosition(this, e.position, !1, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, t).then(e => {
                    this.client.actions.GuildChannelsPositionUpdate.handle({
                        guild_id: this.guild.id,
                        channels: e
                    })
                });
                const s = e.permissionOverwrites && e.permissionOverwrites.map(e => r.resolve(e, this.guild)),
                    i = await this.client.api.channels(this.id).patch({
                        data: {
                            name: (e.name || this.name).trim(),
                            topic: e.topic,
                            nsfw: e.nsfw,
                            bitrate: e.bitrate || this.bitrate,
                            user_limit: void 0 !== e.userLimit ? e.userLimit : this.userLimit,
                            parent_id: e.parentID,
                            lock_permissions: e.lockPermissions,
                            rate_limit_per_user: e.rateLimitPerUser,
                            permission_overwrites: s
                        },
                        reason: t
                    }),
                    n = this._clone();
                return n._patch(i), n
            }
            setName(e, t) {
                return this.edit({
                    name: e
                }, t)
            }
            setParent(e, {
                lockPermissions: t = !0,
                reason: s
            } = {}) {
                return this.edit({
                    parentID: null !== e ? e.hasOwnProperty("id") ? e.id : e : null,
                    lockPermissions: t
                }, s)
            }
            setTopic(e, t) {
                return this.edit({
                    topic: e
                }, t)
            }
            setPosition(e, {
                relative: t,
                reason: s
            } = {}) {
                return u.setPosition(this, e, t, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, s).then(e => (this.client.actions.GuildChannelsPositionUpdate.handle({
                    guild_id: this.guild.id,
                    channels: e
                }), this))
            }
            createInvite({
                temporary: e = !1,
                maxAge: t = 86400,
                maxUses: s = 0,
                unique: i,
                reason: r
            } = {}) {
                return this.client.api.channels(this.id).invites.post({
                    data: {
                        temporary: e,
                        max_age: t,
                        max_uses: s,
                        unique: i
                    },
                    reason: r
                }).then(e => new n(this.client, e))
            }
            async fetchInvites() {
                const e = await this.client.api.channels(this.id).invites.get(),
                    t = new l;
                for (const s of e) {
                    const e = new n(this.client, s);
                    t.set(e.code, e)
                }
                return t
            }
            clone(e = {}) {
                return u.mergeDefault({
                    name: this.name,
                    permissionOverwrites: this.permissionOverwrites,
                    topic: this.topic,
                    type: this.type,
                    nsfw: this.nsfw,
                    parent: this.parent,
                    bitrate: this.bitrate,
                    userLimit: this.userLimit,
                    rateLimitPerUser: this.rateLimitPerUser,
                    reason: null
                }, e), this.guild.channels.create(e.name, e)
            }
            equals(e) {
                let t = e && this.id === e.id && this.type === e.type && this.topic === e.topic && this.position === e.position && this.name === e.name;
                return t && (t = this.permissionOverwrites && e.permissionOverwrites ? this.permissionOverwrites.equals(e.permissionOverwrites) : !this.permissionOverwrites && !e.permissionOverwrites), t
            }
            get deletable() {
                return this.permissionsFor(this.client.user).has(h.FLAGS.MANAGE_CHANNELS, !1)
            }
            get manageable() {
                if (this.client.user.id === this.guild.ownerID) return !0;
                if ("voice" === this.type) {
                    if (!this.permissionsFor(this.client.user).has(h.FLAGS.CONNECT, !1)) return !1
                } else if (!this.viewable) return !1;
                return this.permissionsFor(this.client.user).has(h.FLAGS.MANAGE_CHANNELS, !1)
            }
            get viewable() {
                if (this.client.user.id === this.guild.ownerID) return !0;
                const e = this.permissionsFor(this.client.user);
                return !!e && e.has(h.FLAGS.VIEW_CHANNEL, !1)
            }
            delete(e) {
                return this.client.api.channels(this.id).delete({
                    reason: e
                }).then(() => this)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            {
                Endpoints: n
            } = s(0),
            r = s(8);
        e.exports = class Invite extends i {
            constructor(e, t) {
                super(e), this._patch(t)
            }
            _patch(e) {
                this.guild = e.guild ? this.client.guilds.add(e.guild, !1) : null, this.code = e.code, this.presenceCount = "approximate_presence_count" in e ? e.approximate_presence_count : null, this.memberCount = "approximate_member_count" in e ? e.approximate_member_count : null, this.temporary = "temporary" in e ? e.temporary : null, this.maxAge = "max_age" in e ? e.max_age : null, this.uses = "uses" in e ? e.uses : null, this.maxUses = "max_uses" in e ? e.max_uses : null, this.inviter = e.inviter ? this.client.users.add(e.inviter) : null, this.targetUser = e.target_user ? this.client.users.add(e.target_user) : null, this.targetUserType = "number" == typeof e.target_user_type ? e.target_user_type : null, this.channel = this.client.channels.add(e.channel, this.guild, !1), this.createdTimestamp = "created_at" in e ? new Date(e.created_at).getTime() : null
            }
            get createdAt() {
                return this.createdTimestamp ? new Date(this.createdTimestamp) : null
            }
            get deletable() {
                const e = this.guild;
                if (!e || !this.client.guilds.cache.has(e.id)) return !1;
                if (!e.me) throw new Error("GUILD_UNCACHED_ME");
                return this.channel.permissionsFor(this.client.user).has(r.FLAGS.MANAGE_CHANNELS, !1) || e.me.permissions.has(r.FLAGS.MANAGE_GUILD)
            }
            get expiresTimestamp() {
                return this.createdTimestamp && this.maxAge ? this.createdTimestamp + 1e3 * this.maxAge : null
            }
            get expiresAt() {
                const {
                    expiresTimestamp: e
                } = this;
                return e ? new Date(e) : null
            }
            get url() {
                return n.invite(this.client.options.http.invite, this.code)
            }
            delete(e) {
                return this.client.api.invites[this.code].delete({
                    reason: e
                }).then(() => this)
            }
            toString() {
                return this.url
            }
            toJSON() {
                return super.toJSON({
                    url: !0,
                    expiresTimestamp: !0,
                    presenceCount: !1,
                    memberCount: !1,
                    uses: !1,
                    channel: "channelID",
                    inviter: "inviterID",
                    guild: "guildID"
                })
            }
            valueOf() {
                return this.code
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            {
                Error: n,
                TypeError: r
            } = s(3),
            o = s(8),
            a = s(7),
            c = s(4);
        e.exports = class Role extends i {
            constructor(e, t, s) {
                super(e), this.guild = s, t && this._patch(t)
            }
            _patch(e) {
                this.id = e.id, this.name = e.name, this.color = e.color, this.hoist = e.hoist, this.rawPosition = e.position, this.permissions = new o(e.permissions).freeze(), this.managed = e.managed, this.mentionable = e.mentionable, this.deleted = !1
            }
            get createdTimestamp() {
                return a.deconstruct(this.id).timestamp
            }
            get createdAt() {
                return new Date(this.createdTimestamp)
            }
            get hexColor() {
                return `#${this.color.toString(16).padStart(6,"0")}`
            }
            get members() {
                return this.guild.members.cache.filter(e => e.roles.cache.has(this.id))
            }
            get editable() {
                if (this.managed) return !1;
                const e = this.guild.member(this.client.user);
                return !!e.permissions.has(o.FLAGS.MANAGE_ROLES) && e.roles.highest.comparePositionTo(this) > 0
            }
            get position() {
                const e = this.guild._sortedRoles();
                return e.array().indexOf(e.get(this.id))
            }
            comparePositionTo(e) {
                if (!(e = this.guild.roles.resolve(e))) throw new r("INVALID_TYPE", "role", "Role nor a Snowflake");
                return this.constructor.comparePositions(this, e)
            }
            async edit(e, t) {
                return void 0 !== e.permissions ? e.permissions = o.resolve(e.permissions) : e.permissions = this.permissions.bitfield, void 0 !== e.position && await c.setPosition(this, e.position, !1, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, t).then(e => {
                    this.client.actions.GuildRolesPositionUpdate.handle({
                        guild_id: this.guild.id,
                        roles: e
                    })
                }), this.client.api.guilds[this.guild.id].roles[this.id].patch({
                    data: {
                        name: e.name || this.name,
                        color: null !== e.color ? c.resolveColor(e.color || this.color) : null,
                        hoist: void 0 !== e.hoist ? e.hoist : this.hoist,
                        permissions: e.permissions,
                        mentionable: void 0 !== e.mentionable ? e.mentionable : this.mentionable
                    },
                    reason: t
                }).then(e => {
                    const t = this._clone();
                    return t._patch(e), t
                })
            }
            permissionsIn(e) {
                if (!(e = this.guild.channels.resolve(e))) throw new n("GUILD_CHANNEL_RESOLVE");
                return e.rolePermissions(this)
            }
            setName(e, t) {
                return this.edit({
                    name: e
                }, t)
            }
            setColor(e, t) {
                return this.edit({
                    color: e
                }, t)
            }
            setHoist(e, t) {
                return this.edit({
                    hoist: e
                }, t)
            }
            setPermissions(e, t) {
                return this.edit({
                    permissions: e
                }, t)
            }
            setMentionable(e, t) {
                return this.edit({
                    mentionable: e
                }, t)
            }
            setPosition(e, {
                relative: t,
                reason: s
            } = {}) {
                return c.setPosition(this, e, t, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, s).then(e => (this.client.actions.GuildRolesPositionUpdate.handle({
                    guild_id: this.guild.id,
                    roles: e
                }), this))
            }
            delete(e) {
                return this.client.api.guilds[this.guild.id].roles[this.id].delete({
                    reason: e
                }).then(() => (this.client.actions.GuildRoleDelete.handle({
                    guild_id: this.guild.id,
                    role_id: this.id
                }), this))
            }
            equals(e) {
                return e && this.id === e.id && this.name === e.name && this.color === e.color && this.hoist === e.hoist && this.position === e.position && this.permissions.bitfield === e.permissions.bitfield && this.managed === e.managed
            }
            toString() {
                return this.id === this.guild.id ? "@everyone" : `<@&${this.id}>`
            }
            toJSON() {
                return super.toJSON({
                    createdTimestamp: !0
                })
            }
            static comparePositions(e, t) {
                return e.position === t.position ? t.id - e.id : e.position - t.position
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = {
            GuildEmoji: s(19),
            DMChannel: s(32),
            TextChannel: s(34),
            VoiceChannel: s(65),
            CategoryChannel: s(66),
            NewsChannel: s(67),
            StoreChannel: s(68),
            GuildMember: s(10),
            Guild: s(44),
            Message: s(22),
            MessageReaction: s(42),
            Presence: s(12).Presence,
            ClientPresence: s(75),
            VoiceState: s(21),
            Role: s(17),
            User: s(20)
        };
        e.exports = class Structures {
            constructor() {
                throw new Error(`The ${this.constructor.name} class may not be instantiated.`)
            }
            static get(e) {
                if ("string" == typeof e) return i[e];
                throw new TypeError(`"structure" argument must be a string (received ${typeof e})`)
            }
            static extend(e, t) {
                if (!i[e]) throw new RangeError(`"${e}" is not a valid extensible structure.`);
                if ("function" != typeof t) {
                    throw new TypeError(`"extender" argument must be a function that returns the extended structure class/prototype ${`(received ${typeof t})`}.`)
                }
                const s = t(i[e]);
                if ("function" != typeof s) {
                    throw new TypeError(`The extender function must return the extended structure class/prototype ${`(received ${typeof s})`}.`)
                }
                if (!(s.prototype instanceof i[e])) {
                    const t = Object.getPrototypeOf(s),
                        n = `${s.name||"unnamed"}${t.name?` extends ${t.name}`:""}`;
                    throw new Error("The class/prototype returned from the extender function must extend the existing structure class/prototype" + ` (received function ${n}; expected extension of ${i[e].name}).`)
                }
                return i[e] = s, s
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(33),
            {
                Error: n
            } = s(3),
            r = s(56),
            o = s(8);
        class GuildEmoji extends i {
            _clone() {
                const e = super._clone();
                return e._roles = this._roles.slice(), e
            }
            get deletable() {
                if (!this.guild.me) throw new n("GUILD_UNCACHED_ME");
                return !this.managed && this.guild.me.hasPermission(o.FLAGS.MANAGE_EMOJIS)
            }
            get roles() {
                return new r(this)
            }
            fetchAuthor() {
                return this.managed ? Promise.reject(new n("EMOJI_MANAGED")) : this.guild.me ? this.guild.me.permissions.has(o.FLAGS.MANAGE_EMOJIS) ? this.client.api.guilds(this.guild.id).emojis(this.id).get().then(e => this.client.users.add(e.user)) : Promise.reject(new n("MISSING_MANAGE_EMOJIS_PERMISSION", this.guild)) : Promise.reject(new n("GUILD_UNCACHED_ME"))
            }
            edit(e, t) {
                const s = e.roles ? e.roles.map(e => e.id || e) : void 0;
                return this.client.api.guilds(this.guild.id).emojis(this.id).patch({
                    data: {
                        name: e.name,
                        roles: s
                    },
                    reason: t
                }).then(e => {
                    const t = this._clone();
                    return t._patch(e), t
                })
            }
            setName(e, t) {
                return this.edit({
                    name: e
                }, t)
            }
            delete(e) {
                return this.client.api.guilds(this.guild.id).emojis(this.id).delete({
                    reason: e
                }).then(() => this)
            }
            equals(e) {
                return e instanceof GuildEmoji ? e.id === this.id && e.name === this.name && e.managed === this.managed && e.requiresColons === this.requiresColons && e.roles.cache.size === this.roles.cache.size && e.roles.cache.every(e => this.roles.cache.has(e.id)) : e.id === this.id && e.name === this.name && e.roles.length === this.roles.cache.size && e.roles.every(e => this.roles.cache.has(e))
            }
        }
        e.exports = GuildEmoji
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            {
                Presence: n
            } = s(12),
            r = s(27),
            {
                Error: o
            } = s(3),
            a = s(7);
        class User extends i {
            constructor(e, t) {
                super(e), this.id = t.id, this.bot = Boolean(t.bot), this._patch(t)
            }
            _patch(e) {
                e.username && (this.username = e.username), e.discriminator && (this.discriminator = e.discriminator), void 0 !== e.avatar && (this.avatar = e.avatar), void 0 !== e.bot && (this.bot = Boolean(e.bot)), void 0 !== e.system && (this.system = Boolean(e.system)), e.locale && (this.locale = e.locale), this.lastMessageID = null, this.lastMessageChannelID = null
            }
            get partial() {
                return "string" != typeof this.username
            }
            get createdTimestamp() {
                return a.deconstruct(this.id).timestamp
            }
            get createdAt() {
                return new Date(this.createdTimestamp)
            }
            get lastMessage() {
                const e = this.client.channels.cache.get(this.lastMessageChannelID);
                return e && e.messages.cache.get(this.lastMessageID) || null
            }
            get presence() {
                for (const e of this.client.guilds.cache.values())
                    if (e.presences.cache.has(this.id)) return e.presences.cache.get(this.id);
                return new n(this.client, {
                    user: {
                        id: this.id
                    }
                })
            }
            avatarURL({
                format: e,
                size: t,
                dynamic: s
            } = {}) {
                return this.avatar ? this.client.rest.cdn.Avatar(this.id, this.avatar, e, t, s) : null
            }
            get defaultAvatarURL() {
                return this.client.rest.cdn.DefaultAvatar(this.discriminator % 5)
            }
            displayAvatarURL(e) {
                return this.avatarURL(e) || this.defaultAvatarURL
            }
            get tag() {
                return "string" == typeof this.username ? `${this.username}#${this.discriminator}` : null
            }
            typingIn(e) {
                return (e = this.client.channels.resolve(e))._typing.has(this.id)
            }
            typingSinceIn(e) {
                return (e = this.client.channels.resolve(e))._typing.has(this.id) ? new Date(e._typing.get(this.id).since) : null
            }
            typingDurationIn(e) {
                return (e = this.client.channels.resolve(e))._typing.has(this.id) ? e._typing.get(this.id).elapsedTime : -1
            }
            get dmChannel() {
                return this.client.channels.cache.find(e => "dm" === e.type && e.recipient.id === this.id) || null
            }
            async createDM() {
                const {
                    dmChannel: e
                } = this;
                if (e && !e.partial) return e;
                const t = await this.client.api.users(this.client.user.id).channels.post({
                    data: {
                        recipient_id: this.id
                    }
                });
                return this.client.actions.ChannelCreate.handle(t).channel
            }
            async deleteDM() {
                const {
                    dmChannel: e
                } = this;
                if (!e) throw new o("USER_NO_DMCHANNEL");
                const t = await this.client.api.channels(e.id).delete();
                return this.client.actions.ChannelDelete.handle(t).channel
            }
            equals(e) {
                return e && this.id === e.id && this.username === e.username && this.discriminator === e.discriminator && this.avatar === e.avatar
            }
            fetch() {
                return this.client.users.fetch(this.id, !0)
            }
            toString() {
                return `<@${this.id}>`
            }
            toJSON(...e) {
                const t = super.toJSON({
                    createdTimestamp: !0,
                    defaultAvatarURL: !0,
                    tag: !0,
                    lastMessage: !1,
                    lastMessageID: !1
                }, ...e);
                return t.avatarURL = this.avatarURL(), t.displayAvatarURL = this.displayAvatarURL(), t
            }
            send() {}
        }
        r.applyToClass(User), e.exports = User
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            {
                Error: n,
                TypeError: r
            } = s(3),
            {
                browser: o
            } = s(0);
        e.exports = class VoiceState extends i {
            constructor(e, t) {
                super(e.client), this.guild = e, this.id = t.user_id, this._patch(t)
            }
            _patch(e) {
                return this.serverDeaf = e.deaf, this.serverMute = e.mute, this.selfDeaf = e.self_deaf, this.selfMute = e.self_mute, this.sessionID = e.session_id, this.streaming = e.self_stream || !1, this.channelID = e.channel_id, this
            }
            get member() {
                return this.guild.members.cache.get(this.id) || null
            }
            get channel() {
                return this.guild.channels.cache.get(this.channelID) || null
            }
            get connection() {
                return o || this.id !== this.client.user.id ? null : this.client.voice.connections.get(this.guild.id) || null
            }
            get deaf() {
                return this.serverDeaf || this.selfDeaf
            }
            get mute() {
                return this.serverMute || this.selfMute
            }
            get speaking() {
                return this.channel && this.channel.connection ? Boolean(this.channel.connection._speaking.get(this.id)) : null
            }
            setMute(e, t) {
                return this.member ? this.member.edit({
                    mute: e
                }, t) : Promise.reject(new n("VOICE_STATE_UNCACHED_MEMBER"))
            }
            setDeaf(e, t) {
                return this.member ? this.member.edit({
                    deaf: e
                }, t) : Promise.reject(new n("VOICE_STATE_UNCACHED_MEMBER"))
            }
            kick(e) {
                return this.setChannel(null, e)
            }
            setChannel(e, t) {
                return this.member ? this.member.edit({
                    channel: e
                }, t) : Promise.reject(new n("VOICE_STATE_UNCACHED_MEMBER"))
            }
            async setSelfMute(e) {
                if (this.id !== this.client.user.id) throw new n("VOICE_STATE_NOT_OWN");
                if ("boolean" != typeof e) throw new r("VOICE_STATE_INVALID_TYPE", "mute");
                return !!this.connection && (this.selfMute = e, await this.connection.sendVoiceStateUpdate(), !0)
            }
            async setSelfDeaf(e) {
                return this.id !== this.client.user.id ? new n("VOICE_STATE_NOT_OWN") : "boolean" != typeof e ? new r("VOICE_STATE_INVALID_TYPE", "deaf") : !!this.connection && (this.selfDeaf = e, await this.connection.sendVoiceStateUpdate(), !0)
            }
            toJSON() {
                return super.toJSON({
                    id: !0,
                    serverDeaf: !0,
                    serverMute: !0,
                    selfDeaf: !0,
                    selfMute: !0,
                    sessionID: !0,
                    channelID: "channel"
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(26),
            n = s(5),
            r = s(41),
            o = s(36),
            a = s(37),
            c = s(62),
            l = s(63),
            {
                Error: h,
                TypeError: u
            } = s(3),
            d = s(105),
            p = s(2),
            {
                MessageTypes: m
            } = s(0),
            g = s(38),
            E = s(8),
            f = s(4);
        e.exports = class Message extends n {
            constructor(e, t, s) {
                super(e), this.channel = s, this.deleted = !1, t && this._patch(t)
            }
            _patch(e) {
                if (this.id = e.id, this.type = m[e.type], this.content = e.content, this.author = e.author ? this.client.users.add(e.author, !e.webhook_id) : null, this.pinned = e.pinned, this.tts = e.tts, this.nonce = e.nonce, this.system = 0 !== e.type, this.embeds = (e.embeds || []).map(e => new a(e, !0)), this.attachments = new p, e.attachments)
                    for (const t of e.attachments) this.attachments.set(t.id, new o(t.url, t.filename, t));
                if (this.createdTimestamp = new Date(e.timestamp).getTime(), this.editedTimestamp = e.edited_timestamp ? new Date(e.edited_timestamp).getTime() : null, this.reactions = new d(this), e.reactions && e.reactions.length > 0)
                    for (const t of e.reactions) this.reactions.add(t);
                this.mentions = new c(this, e.mentions, e.mention_roles, e.mention_everyone, e.mention_channels), this.webhookID = e.webhook_id || null, this.application = e.application ? new r(this.client, e.application) : null, this.activity = e.activity ? {
                    partyID: e.activity.party_id,
                    type: e.activity.type
                } : null, this._edits = [], this.member && e.member ? this.member._patch(e.member) : e.member && this.guild && this.author && this.guild.members.add(Object.assign(e.member, {
                    user: this.author
                })), this.flags = new g(e.flags).freeze(), this.reference = e.message_reference ? {
                    channelID: e.message_reference.channel_id,
                    guildID: e.message_reference.guild_id,
                    messageID: e.message_reference.message_id
                } : null
            }
            get partial() {
                return "string" != typeof this.content || !this.author
            }
            patch(e) {
                const t = this._clone();
                if (this._edits.unshift(t), "edited_timestamp" in e && (this.editedTimestamp = new Date(e.edited_timestamp).getTime()), "content" in e && (this.content = e.content), "pinned" in e && (this.pinned = e.pinned), "tts" in e && (this.tts = e.tts), this.embeds = "embeds" in e ? e.embeds.map(e => new a(e, !0)) : this.embeds.slice(), "attachments" in e) {
                    this.attachments = new p;
                    for (const t of e.attachments) this.attachments.set(t.id, new o(t.url, t.filename, t))
                } else this.attachments = new p(this.attachments);
                this.mentions = new c(this, "mentions" in e ? e.mentions : this.mentions.users, "mentions_roles" in e ? e.mentions_roles : this.mentions.roles, "mention_everyone" in e ? e.mention_everyone : this.mentions.everyone, "mention_channels" in e ? e.mention_channels : this.mentions.crosspostedChannels), this.flags = new g("flags" in e ? e.flags : 0).freeze()
            }
            get member() {
                return this.guild && this.guild.member(this.author) || null
            }
            get createdAt() {
                return new Date(this.createdTimestamp)
            }
            get editedAt() {
                return this.editedTimestamp ? new Date(this.editedTimestamp) : null
            }
            get guild() {
                return this.channel.guild || null
            }
            get url() {
                return `https://discordapp.com/channels/${this.guild?this.guild.id:"@me"}/${this.channel.id}/${this.id}`
            }
            get cleanContent() {
                return null != this.content ? f.cleanContent(this.content, this) : null
            }
            createReactionCollector(e, t = {}) {
                return new l(this, e, t)
            }
            awaitReactions(e, t = {}) {
                return new Promise((s, i) => {
                    this.createReactionCollector(e, t).once("end", (e, n) => {
                        t.errors && t.errors.includes(n) ? i(e) : s(e)
                    })
                })
            }
            get edits() {
                const e = this._edits.slice();
                return e.unshift(this), e
            }
            get editable() {
                return this.author.id === this.client.user.id
            }
            get deletable() {
                return !this.deleted && (this.author.id === this.client.user.id || this.guild && this.channel.permissionsFor(this.client.user).has(E.FLAGS.MANAGE_MESSAGES, !1))
            }
            get pinnable() {
                return "DEFAULT" === this.type && (!this.guild || this.channel.permissionsFor(this.client.user).has(E.FLAGS.MANAGE_MESSAGES, !1))
            }
            edit(e, t) {
                const {
                    data: s
                } = e instanceof i ? e.resolveData() : i.create(this, e, t).resolveData();
                return this.client.api.channels[this.channel.id].messages[this.id].patch({
                    data: s
                }).then(e => {
                    const t = this._clone();
                    return t._patch(e), t
                })
            }
            pin() {
                return this.client.api.channels(this.channel.id).pins(this.id).put().then(() => this)
            }
            unpin() {
                return this.client.api.channels(this.channel.id).pins(this.id).delete().then(() => this)
            }
            react(e) {
                if (!(e = this.client.emojis.resolveIdentifier(e))) throw new u("EMOJI_TYPE");
                return this.client.api.channels(this.channel.id).messages(this.id).reactions(e, "@me").put().then(() => this.client.actions.MessageReactionAdd.handle({
                    user: this.client.user,
                    channel: this.channel,
                    message: this,
                    emoji: f.parseEmoji(e)
                }).reaction)
            }
            delete(e = {}) {
                if ("object" != typeof e) throw new u("INVALID_TYPE", "options", "object", !0);
                const {
                    timeout: t = 0,
                    reason: s
                } = e;
                return t <= 0 ? this.channel.messages.delete(this.id, s).then(() => this) : new Promise(e => {
                    this.client.setTimeout(() => {
                        e(this.delete({
                            reason: s
                        }))
                    }, t)
                })
            }
            reply(e, t) {
                return this.channel.send(e instanceof i ? e : i.transformOptions(e, t, {
                    reply: this.member || this.author
                }))
            }
            fetch() {
                return this.channel.messages.fetch(this.id, !0)
            }
            fetchWebhook() {
                return this.webhookID ? this.client.fetchWebhook(this.webhookID) : Promise.reject(new h("WEBHOOK_MESSAGE"))
            }
            suppressEmbeds(e = !0) {
                const t = new g(this.flags.bitfield);
                return e ? t.add(g.FLAGS.SUPPRESS_EMBEDS) : t.remove(g.FLAGS.SUPPRESS_EMBEDS), this.edit({
                    flags: t
                })
            }
            equals(e, t) {
                if (!e) return !1;
                if (!e.author && !e.attachments) return this.id === e.id && this.embeds.length === e.embeds.length;
                let s = this.id === e.id && this.author.id === e.author.id && this.content === e.content && this.tts === e.tts && this.nonce === e.nonce && this.embeds.length === e.embeds.length && this.attachments.length === e.attachments.length;
                return s && t && (s = this.mentions.everyone === e.mentions.everyone && this.createdTimestamp === new Date(t.timestamp).getTime() && this.editedTimestamp === new Date(t.edited_timestamp).getTime()), s
            }
            toString() {
                return this.content
            }
            toJSON() {
                return super.toJSON({
                    channel: "channelID",
                    author: "authorID",
                    application: "applicationID",
                    guild: "guildID",
                    cleanContent: !0,
                    member: !1,
                    reactions: !1
                })
            }
        }
    }, function (e, t) {
        var s, i, n = e.exports = {};

        function r() {
            throw new Error("setTimeout has not been defined")
        }

        function o() {
            throw new Error("clearTimeout has not been defined")
        }

        function a(e) {
            if (s === setTimeout) return setTimeout(e, 0);
            if ((s === r || !s) && setTimeout) return s = setTimeout, setTimeout(e, 0);
            try {
                return s(e, 0)
            } catch (t) {
                try {
                    return s.call(null, e, 0)
                } catch (t) {
                    return s.call(this, e, 0)
                }
            }
        }! function () {
            try {
                s = "function" == typeof setTimeout ? setTimeout : r
            } catch (e) {
                s = r
            }
            try {
                i = "function" == typeof clearTimeout ? clearTimeout : o
            } catch (e) {
                i = o
            }
        }();
        var c, l = [],
            h = !1,
            u = -1;

        function d() {
            h && c && (h = !1, c.length ? l = c.concat(l) : u = -1, l.length && p())
        }

        function p() {
            if (!h) {
                var e = a(d);
                h = !0;
                for (var t = l.length; t;) {
                    for (c = l, l = []; ++u < t;) c && c[u].run();
                    u = -1, t = l.length
                }
                c = null, h = !1,
                    function (e) {
                        if (i === clearTimeout) return clearTimeout(e);
                        if ((i === o || !i) && clearTimeout) return i = clearTimeout, clearTimeout(e);
                        try {
                            i(e)
                        } catch (t) {
                            try {
                                return i.call(null, e)
                            } catch (t) {
                                return i.call(this, e)
                            }
                        }
                    }(e)
            }
        }

        function m(e, t) {
            this.fun = e, this.array = t
        }

        function g() {}
        n.nextTick = function (e) {
            var t = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var s = 1; s < arguments.length; s++) t[s - 1] = arguments[s];
            l.push(new m(e, t)), 1 !== l.length || h || a(p)
        }, m.prototype.run = function () {
            this.fun.apply(null, this.array)
        }, n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = g, n.addListener = g, n.once = g, n.off = g, n.removeListener = g, n.removeAllListeners = g, n.emit = g, n.prependListener = g, n.prependOnceListener = g, n.listeners = function (e) {
            return []
        }, n.binding = function (e) {
            throw new Error("process.binding is not supported")
        }, n.cwd = function () {
            return "/"
        }, n.chdir = function (e) {
            throw new Error("process.chdir is not supported")
        }, n.umask = function () {
            return 0
        }
    }, function (e, t, s) {
        "use strict";
        var i, n = "object" == typeof Reflect ? Reflect : null,
            r = n && "function" == typeof n.apply ? n.apply : function (e, t, s) {
                return Function.prototype.apply.call(e, t, s)
            };
        i = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function (e) {
            return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
        } : function (e) {
            return Object.getOwnPropertyNames(e)
        };
        var o = Number.isNaN || function (e) {
            return e != e
        };

        function a() {
            a.init.call(this)
        }
        e.exports = a, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
        var c = 10;

        function l(e) {
            if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
        }

        function h(e) {
            return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners
        }

        function u(e, t, s, i) {
            var n, r, o, a;
            if (l(s), void 0 === (r = e._events) ? (r = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== r.newListener && (e.emit("newListener", t, s.listener ? s.listener : s), r = e._events), o = r[t]), void 0 === o) o = r[t] = s, ++e._eventsCount;
            else if ("function" == typeof o ? o = r[t] = i ? [s, o] : [o, s] : i ? o.unshift(s) : o.push(s), (n = h(e)) > 0 && o.length > n && !o.warned) {
                o.warned = !0;
                var c = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                c.name = "MaxListenersExceededWarning", c.emitter = e, c.type = t, c.count = o.length, a = c, console && console.warn && console.warn(a)
            }
            return e
        }

        function d() {
            if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
        }

        function p(e, t, s) {
            var i = {
                    fired: !1,
                    wrapFn: void 0,
                    target: e,
                    type: t,
                    listener: s
                },
                n = d.bind(i);
            return n.listener = s, i.wrapFn = n, n
        }

        function m(e, t, s) {
            var i = e._events;
            if (void 0 === i) return [];
            var n = i[t];
            return void 0 === n ? [] : "function" == typeof n ? s ? [n.listener || n] : [n] : s ? function (e) {
                for (var t = new Array(e.length), s = 0; s < t.length; ++s) t[s] = e[s].listener || e[s];
                return t
            }(n) : E(n, n.length)
        }

        function g(e) {
            var t = this._events;
            if (void 0 !== t) {
                var s = t[e];
                if ("function" == typeof s) return 1;
                if (void 0 !== s) return s.length
            }
            return 0
        }

        function E(e, t) {
            for (var s = new Array(t), i = 0; i < t; ++i) s[i] = e[i];
            return s
        }
        Object.defineProperty(a, "defaultMaxListeners", {
            enumerable: !0,
            get: function () {
                return c
            },
            set: function (e) {
                if ("number" != typeof e || e < 0 || o(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                c = e
            }
        }), a.init = function () {
            void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
        }, a.prototype.setMaxListeners = function (e) {
            if ("number" != typeof e || e < 0 || o(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
            return this._maxListeners = e, this
        }, a.prototype.getMaxListeners = function () {
            return h(this)
        }, a.prototype.emit = function (e) {
            for (var t = [], s = 1; s < arguments.length; s++) t.push(arguments[s]);
            var i = "error" === e,
                n = this._events;
            if (void 0 !== n) i = i && void 0 === n.error;
            else if (!i) return !1;
            if (i) {
                var o;
                if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
                var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
                throw a.context = o, a
            }
            var c = n[e];
            if (void 0 === c) return !1;
            if ("function" == typeof c) r(c, this, t);
            else {
                var l = c.length,
                    h = E(c, l);
                for (s = 0; s < l; ++s) r(h[s], this, t)
            }
            return !0
        }, a.prototype.addListener = function (e, t) {
            return u(this, e, t, !1)
        }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function (e, t) {
            return u(this, e, t, !0)
        }, a.prototype.once = function (e, t) {
            return l(t), this.on(e, p(this, e, t)), this
        }, a.prototype.prependOnceListener = function (e, t) {
            return l(t), this.prependListener(e, p(this, e, t)), this
        }, a.prototype.removeListener = function (e, t) {
            var s, i, n, r, o;
            if (l(t), void 0 === (i = this._events)) return this;
            if (void 0 === (s = i[e])) return this;
            if (s === t || s.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, s.listener || t));
            else if ("function" != typeof s) {
                for (n = -1, r = s.length - 1; r >= 0; r--)
                    if (s[r] === t || s[r].listener === t) {
                        o = s[r].listener, n = r;
                        break
                    } if (n < 0) return this;
                0 === n ? s.shift() : function (e, t) {
                    for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                    e.pop()
                }(s, n), 1 === s.length && (i[e] = s[0]), void 0 !== i.removeListener && this.emit("removeListener", e, o || t)
            }
            return this
        }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function (e) {
            var t, s, i;
            if (void 0 === (s = this._events)) return this;
            if (void 0 === s.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== s[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete s[e]), this;
            if (0 === arguments.length) {
                var n, r = Object.keys(s);
                for (i = 0; i < r.length; ++i) "removeListener" !== (n = r[i]) && this.removeAllListeners(n);
                return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
            }
            if ("function" == typeof (t = s[e])) this.removeListener(e, t);
            else if (void 0 !== t)
                for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
            return this
        }, a.prototype.listeners = function (e) {
            return m(this, e, !0)
        }, a.prototype.rawListeners = function (e) {
            return m(this, e, !1)
        }, a.listenerCount = function (e, t) {
            return "function" == typeof e.listenerCount ? e.listenerCount(t) : g.call(e, t)
        }, a.prototype.listenerCount = g, a.prototype.eventNames = function () {
            return this._eventsCount > 0 ? i(this._events) : []
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            n = s(7);
        e.exports = class Emoji extends i {
            constructor(e, t) {
                super(e), this.animated = t.animated, this.name = t.name, this.id = t.id, this.deleted = !1
            }
            get identifier() {
                return this.id ? `${this.animated?"a:":""}${this.name}:${this.id}` : encodeURIComponent(this.name)
            }
            get url() {
                return this.id ? this.client.rest.cdn.Emoji(this.id, this.animated ? "gif" : "png") : null
            }
            get createdTimestamp() {
                return this.id ? n.deconstruct(this.id).timestamp : null
            }
            get createdAt() {
                return this.id ? new Date(this.createdTimestamp) : null
            }
            toString() {
                return this.id ? `<${this.animated?"a":""}:${this.name}:${this.id}>` : this.name
            }
            toJSON() {
                return super.toJSON({
                    guild: "guildID",
                    createdTimestamp: !0,
                    url: !0,
                    identifier: !0
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(36),
            n = s(37),
            {
                RangeError: r
            } = s(3),
            {
                browser: o
            } = s(0),
            a = s(9),
            c = s(38),
            l = s(4);
        class APIMessage {
            constructor(e, t) {
                this.target = e, this.options = t, this.data = null, this.files = null
            }
            get isWebhook() {
                const e = s(11),
                    t = s(39);
                return this.target instanceof e || this.target instanceof t
            }
            get isUser() {
                const e = s(20),
                    t = s(10);
                return this.target instanceof e || this.target instanceof t
            }
            get isMessage() {
                const e = s(22);
                return this.target instanceof e
            }
            makeContent() {
                const e = s(10);
                let t;
                null === this.options.content ? t = "" : void 0 !== this.options.content && (t = l.resolveString(this.options.content));
                const i = void 0 === this.options.disableMentions ? this.target.client.options.disableMentions : this.options.disableMentions;
                "all" === i ? t = l.removeMentions(t || "") : "everyone" === i && (t = (t || "").replace(/@([^<>@ ]*)/gmus, (e, t) => t.match(/^[&!]?\d+$/) ? `@${t}` : `@​${t}`));
                const n = void 0 !== this.options.split && !1 !== this.options.split,
                    r = void 0 !== this.options.code && !1 !== this.options.code,
                    o = n ? {
                        ...this.options.split
                    } : void 0;
                let a = "";
                if (this.options.reply && !this.isUser && "dm" !== this.target.type) {
                    const t = this.target.client.users.resolveID(this.options.reply);
                    a = `<@${this.options.reply instanceof e&&this.options.reply.nickname?"!":""}${t}>, `, n && (o.prepend = `${a}${o.prepend||""}`)
                }
                if (t || a) {
                    if (r) {
                        const e = "string" == typeof this.options.code ? this.options.code : "";
                        t = `${a}\`\`\`${e}\n${l.cleanCodeBlockContent(t||"")}\n\`\`\``, n && (o.prepend = `${o.prepend||""}\`\`\`${e}\n`, o.append = `\n\`\`\`${o.append||""}`)
                    } else a && (t = `${a}${t||""}`);
                    n && (t = l.splitMessage(t || "", o))
                }
                return t
            }
            resolveData() {
                if (this.data) return this;
                const e = this.makeContent(),
                    t = Boolean(this.options.tts);
                let s;
                if (void 0 !== this.options.nonce && (s = parseInt(this.options.nonce), isNaN(s) || s < 0)) throw new r("MESSAGE_NONCE_TYPE");
                const i = [];
                this.isWebhook ? this.options.embeds && i.push(...this.options.embeds) : this.options.embed && i.push(this.options.embed);
                const o = i.map(e => new n(e).toJSON());
                let a, l, h;
                return this.isWebhook && (a = this.options.username || this.target.name, this.options.avatarURL && (l = this.options.avatarURL)), this.isMessage && (h = null != this.options.flags ? new c(this.options.flags).bitfield : this.target.flags.bitfield), this.data = {
                    content: e,
                    tts: t,
                    nonce: s,
                    embed: null === this.options.embed ? null : o[0],
                    embeds: o,
                    username: a,
                    avatar_url: l,
                    allowed_mentions: this.options.allowedMentions,
                    flags: h
                }, this
            }
            async resolveFiles() {
                if (this.files) return this;
                const e = [];
                this.isWebhook ? this.options.embeds && e.push(...this.options.embeds) : this.options.embed && e.push(this.options.embed);
                const t = [];
                this.options.files && t.push(...this.options.files);
                for (const s of e) s.files && t.push(...s.files);
                return this.files = await Promise.all(t.map(e => this.constructor.resolveFile(e))), this
            }
            split() {
                if (this.data || this.resolveData(), !Array.isArray(this.data.content)) return [this];
                const e = [];
                for (let t = 0; t < this.data.content.length; t++) {
                    let s, i;
                    t === this.data.content.length - 1 ? (s = {
                        ...this.data,
                        content: this.data.content[t]
                    }, i = {
                        ...this.options,
                        content: this.data.content[t]
                    }) : (s = {
                        content: this.data.content[t],
                        tts: this.data.tts
                    }, i = {
                        content: this.data.content[t],
                        tts: this.data.tts
                    });
                    const n = new APIMessage(this.target, i);
                    n.data = s, e.push(n)
                }
                return e
            }
            static async resolveFile(e) {
                let t, s;
                const i = e => "string" == typeof e ? l.basename(e) : e.path ? l.basename(e.path) : "file.jpg";
                return "string" == typeof e || e instanceof(o ? ArrayBuffer : Buffer) || "function" == typeof e.pipe ? (t = e, s = i(t)) : (t = e.attachment, s = e.name || i(t)), {
                    attachment: t,
                    name: s,
                    file: await a.resolveFile(t)
                }
            }
            static partitionMessageAdditions(e) {
                const t = [],
                    s = [];
                for (const r of e) r instanceof n ? t.push(r) : r instanceof i && s.push(r);
                return [t, s]
            }
            static transformOptions(e, t, s = {}, r = !1) {
                if (t || "object" != typeof e || Array.isArray(e) || (t = e, e = void 0), t) {
                    if (t instanceof n) return r ? {
                        content: e,
                        embeds: [t],
                        ...s
                    } : {
                        content: e,
                        embed: t,
                        ...s
                    };
                    if (t instanceof i) return {
                        content: e,
                        files: [t],
                        ...s
                    }
                } else t = {};
                if (Array.isArray(t)) {
                    const [i, n] = this.partitionMessageAdditions(t);
                    return r ? {
                        content: e,
                        embeds: i,
                        files: n,
                        ...s
                    } : {
                        content: e,
                        embed: i[0],
                        files: n,
                        ...s
                    }
                }
                if (Array.isArray(e)) {
                    const [t, i] = this.partitionMessageAdditions(e);
                    if (t.length || i.length) return r ? {
                        embeds: t,
                        files: i,
                        ...s
                    } : {
                        embed: t[0],
                        files: i,
                        ...s
                    }
                }
                return {
                    content: e,
                    ...t,
                    ...s
                }
            }
            static create(e, t, i, n = {}) {
                const r = s(11),
                    o = s(39),
                    a = e instanceof r || e instanceof o;
                return new this(e, this.transformOptions(t, i, n, a))
            }
        }
        e.exports = APIMessage
    }, function (e, t, s) {
        "use strict";
        const i = s(58),
            n = s(26),
            r = s(7),
            o = s(2),
            {
                RangeError: a,
                TypeError: c
            } = s(3);
        class TextBasedChannel {
            constructor() {
                this.messages = new l(this), this.lastMessageID = null, this.lastPinTimestamp = null
            }
            get lastMessage() {
                return this.messages.cache.get(this.lastMessageID) || null
            }
            get lastPinAt() {
                return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null
            }
            async send(e, t) {
                const i = s(20),
                    r = s(10);
                if (this instanceof i || this instanceof r) return this.createDM().then(s => s.send(e, t));
                let o;
                if (e instanceof n) o = e.resolveData();
                else if (o = n.create(this, e, t).resolveData(), Array.isArray(o.data.content)) return Promise.all(o.split().map(this.send.bind(this)));
                const {
                    data: a,
                    files: c
                } = await o.resolveFiles();
                return this.client.api.channels[this.id].messages.post({
                    data: a,
                    files: c
                }).then(e => this.client.actions.MessageCreate.handle(e).message)
            }
            startTyping(e) {
                if (void 0 !== e && e < 1) throw new a("TYPING_COUNT");
                if (this.client.user._typing.has(this.id)) {
                    const t = this.client.user._typing.get(this.id);
                    return t.count = e || t.count + 1, t.promise
                }
                const t = {};
                return t.promise = new Promise((s, i) => {
                    const n = this.client.api.channels[this.id].typing;
                    Object.assign(t, {
                        count: e || 1,
                        interval: this.client.setInterval(() => {
                            n.post().catch(e => {
                                this.client.clearInterval(t.interval), this.client.user._typing.delete(this.id), i(e)
                            })
                        }, 9e3),
                        resolve: s
                    }), n.post().catch(e => {
                        this.client.clearInterval(t.interval), this.client.user._typing.delete(this.id), i(e)
                    }), this.client.user._typing.set(this.id, t)
                }), t.promise
            }
            stopTyping(e = !1) {
                if (this.client.user._typing.has(this.id)) {
                    const t = this.client.user._typing.get(this.id);
                    t.count--, (t.count <= 0 || e) && (this.client.clearInterval(t.interval), this.client.user._typing.delete(this.id), t.resolve())
                }
            }
            get typing() {
                return this.client.user._typing.has(this.id)
            }
            get typingCount() {
                return this.client.user._typing.has(this.id) ? this.client.user._typing.get(this.id).count : 0
            }
            createMessageCollector(e, t = {}) {
                return new i(this, e, t)
            }
            awaitMessages(e, t = {}) {
                return new Promise((s, i) => {
                    this.createMessageCollector(e, t).once("end", (e, n) => {
                        t.errors && t.errors.includes(n) ? i(e) : s(e)
                    })
                })
            }
            async bulkDelete(e, t = !1) {
                if (Array.isArray(e) || e instanceof o) {
                    let s = e instanceof o ? e.keyArray() : e.map(e => e.id || e);
                    if (t && (s = s.filter(e => Date.now() - r.deconstruct(e).date.getTime() < 12096e5)), 0 === s.length) return new o;
                    if (1 === s.length) {
                        await this.client.api.channels(this.id).messages(s[0]).delete();
                        const e = this.client.actions.MessageDelete.getMessage({
                            message_id: s[0]
                        }, this);
                        return e ? new o([
                            [e.id, e]
                        ]) : new o
                    }
                    return await this.client.api.channels[this.id].messages["bulk-delete"].post({
                        data: {
                            messages: s
                        }
                    }), s.reduce((e, t) => e.set(t, this.client.actions.MessageDeleteBulk.getMessage({
                        message_id: t
                    }, this)), new o)
                }
                if (!isNaN(e)) {
                    const s = await this.messages.fetch({
                        limit: e
                    });
                    return this.bulkDelete(s, t)
                }
                throw new c("MESSAGE_BULK_DELETE_TYPE")
            }
            static applyToClass(e, t = !1, s = []) {
                const i = ["send"];
                t && i.push("lastMessage", "lastPinAt", "bulkDelete", "startTyping", "stopTyping", "typing", "typingCount", "createMessageCollector", "awaitMessages");
                for (const t of i) s.includes(t) || Object.defineProperty(e.prototype, t, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, t))
            }
        }
        e.exports = TextBasedChannel;
        const l = s(28)
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            n = s(22),
            r = s(2),
            o = s(106);
        e.exports = class MessageManager extends i {
            constructor(e, t) {
                super(e.client, t, n, o, e.client.options.messageCacheMaxSize), this.channel = e
            }
            add(e, t) {
                return super.add(e, t, {
                    extras: [this.channel]
                })
            }
            fetch(e, t = !0) {
                return "string" == typeof e ? this._fetchId(e, t) : this._fetchMany(e, t)
            }
            fetchPinned(e = !0) {
                return this.client.api.channels[this.channel.id].pins.get().then(t => {
                    const s = new r;
                    for (const i of t) s.set(i.id, this.add(i, e));
                    return s
                })
            }
            async delete(e, t) {
                (e = this.resolveID(e)) && await this.client.api.channels(this.channel.id).messages(e).delete({
                    reason: t
                })
            }
            async _fetchId(e, t) {
                const s = this.cache.get(e);
                if (s && !s.partial) return s;
                const i = await this.client.api.channels[this.channel.id].messages[e].get();
                return this.add(i, t)
            }
            async _fetchMany(e = {}, t) {
                const s = await this.client.api.channels[this.channel.id].messages.get({
                        query: e
                    }),
                    i = new r;
                for (const e of s) i.set(e.id, this.add(e, t));
                return i
            }
        }
    }, function (e, t) {}, function (e, t, s) {
        "use strict";
        var i = function () {
            if ("undefined" != typeof self) return self;
            if ("undefined" != typeof window) return window;
            if (void 0 !== i) return i;
            throw new Error("unable to locate global object")
        }();
        e.exports = t = i.fetch, t.default = i.fetch.bind(i), t.Headers = i.Headers, t.Request = i.Request, t.Response = i.Response
    }, function (e, t, s) {
        "use strict";
        (function (t, i) {
            s(53);
            const n = s(24),
                r = s(86),
                {
                    DefaultOptions: o
                } = s(0),
                a = s(4);
            e.exports = class BaseClient extends n {
                constructor(e = {}) {
                    super(), this._timeouts = new Set, this._intervals = new Set, this._immediates = new Set, this.options = a.mergeDefault(o, e), this.rest = new r(this, e._tokenType)
                }
                get api() {
                    return this.rest.api
                }
                destroy() {
                    for (const e of this._timeouts) this.clearTimeout(e);
                    for (const e of this._intervals) this.clearInterval(e);
                    for (const e of this._immediates) this.clearImmediate(e);
                    this._timeouts.clear(), this._intervals.clear(), this._immediates.clear()
                }
                setTimeout(e, t, ...s) {
                    const i = setTimeout(() => {
                        e(...s), this._timeouts.delete(i)
                    }, t);
                    return this._timeouts.add(i), i
                }
                clearTimeout(e) {
                    clearTimeout(e), this._timeouts.delete(e)
                }
                setInterval(e, t, ...s) {
                    const i = setInterval(e, t, ...s);
                    return this._intervals.add(i), i
                }
                clearInterval(e) {
                    clearInterval(e), this._intervals.delete(e)
                }
                setImmediate(e, ...s) {
                    const i = t(e, ...s);
                    return this._immediates.add(i), i
                }
                clearImmediate(e) {
                    i(e), this._immediates.delete(e)
                }
                toJSON(...e) {
                    return a.flatten(this, {
                        domain: !1
                    }, ...e)
                }
            }
        }).call(this, s(51).setImmediate, s(51).clearImmediate)
    }, function (e, t, s) {
        "use strict";
        const i = s(13),
            n = s(27),
            r = s(28);
        class DMChannel extends i {
            constructor(e, t) {
                super(e, t), this.type = "dm", this.messages = new r(this), this._typing = new Map
            }
            _patch(e) {
                super._patch(e), e.recipients && (this.recipient = this.client.users.add(e.recipients[0])), this.lastMessageID = e.last_message_id, this.lastPinTimestamp = e.last_pin_timestamp ? new Date(e.last_pin_timestamp).getTime() : null
            }
            get partial() {
                return void 0 === this.lastMessageID
            }
            fetch() {
                return this.recipient.createDM()
            }
            toString() {
                return this.recipient.toString()
            }
            get lastMessage() {}
            get lastPinAt() {}
            send() {}
            startTyping() {}
            stopTyping() {}
            get typing() {}
            get typingCount() {}
            createMessageCollector() {}
            awaitMessages() {}
        }
        n.applyToClass(DMChannel, !0, ["bulkDelete"]), e.exports = DMChannel
    }, function (e, t, s) {
        "use strict";
        const i = s(25);
        e.exports = class BaseGuildEmoji extends i {
            constructor(e, t, s) {
                super(e, t), this.guild = s, Object.defineProperty(this, "_roles", {
                    value: [],
                    writable: !0
                }), this._patch(t)
            }
            _patch(e) {
                e.name && (this.name = e.name), void 0 !== e.require_colons && (this.requiresColons = e.require_colons), void 0 !== e.managed && (this.managed = e.managed), void 0 !== e.available && (this.available = e.available), e.roles && (this._roles = e.roles)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(15),
            n = s(11),
            r = s(27),
            o = s(28),
            a = s(2),
            c = s(9);
        class TextChannel extends i {
            constructor(e, t) {
                super(e, t), this.messages = new o(this), this._typing = new Map
            }
            _patch(e) {
                if (super._patch(e), this.topic = e.topic, this.nsfw = e.nsfw, this.lastMessageID = e.last_message_id, this.rateLimitPerUser = e.rate_limit_per_user || 0, this.lastPinTimestamp = e.last_pin_timestamp ? new Date(e.last_pin_timestamp).getTime() : null, e.messages)
                    for (const t of e.messages) this.messages.add(t)
            }
            setRateLimitPerUser(e, t) {
                return this.edit({
                    rateLimitPerUser: e
                }, t)
            }
            setNSFW(e, t) {
                return this.edit({
                    nsfw: e
                }, t)
            }
            fetchWebhooks() {
                return this.client.api.channels[this.id].webhooks.get().then(e => {
                    const t = new a;
                    for (const s of e) t.set(s.id, new n(this.client, s));
                    return t
                })
            }
            async createWebhook(e, {
                avatar: t,
                reason: s
            } = {}) {
                return "string" != typeof t || t.startsWith("data:") || (t = await c.resolveImage(t)), this.client.api.channels[this.id].webhooks.post({
                    data: {
                        name: e,
                        avatar: t
                    },
                    reason: s
                }).then(e => new n(this.client, e))
            }
            get lastMessage() {}
            get lastPinAt() {}
            send() {}
            startTyping() {}
            stopTyping() {}
            get typing() {}
            get typingCount() {}
            createMessageCollector() {}
            awaitMessages() {}
            bulkDelete() {}
        }
        r.applyToClass(TextChannel, !0), e.exports = TextChannel
    }, function (e, t, s) {
        "use strict";
        const i = s(17),
            {
                TypeError: n
            } = s(3),
            r = s(8),
            o = s(4);
        e.exports = class PermissionOverwrites {
            constructor(e, t) {
                Object.defineProperty(this, "channel", {
                    value: e
                }), t && this._patch(t)
            }
            _patch(e) {
                this.id = e.id, this.type = e.type, this.deny = new r(e.deny).freeze(), this.allow = new r(e.allow).freeze()
            }
            update(e, t) {
                const {
                    allow: s,
                    deny: i
                } = this.constructor.resolveOverwriteOptions(e, this);
                return this.channel.client.api.channels(this.channel.id).permissions[this.id].put({
                    data: {
                        id: this.id,
                        type: this.type,
                        allow: s.bitfield,
                        deny: i.bitfield
                    },
                    reason: t
                }).then(() => this)
            }
            delete(e) {
                return this.channel.client.api.channels[this.channel.id].permissions[this.id].delete({
                    reason: e
                }).then(() => this)
            }
            toJSON() {
                return o.flatten(this)
            }
            static resolveOverwriteOptions(e, {
                allow: t,
                deny: s
            } = {}) {
                t = new r(t), s = new r(s);
                for (const [i, n] of Object.entries(e)) !0 === n ? (t.add(r.FLAGS[i]), s.remove(r.FLAGS[i])) : !1 === n ? (t.remove(r.FLAGS[i]), s.add(r.FLAGS[i])) : null === n && (t.remove(r.FLAGS[i]), s.remove(r.FLAGS[i]));
                return {
                    allow: t,
                    deny: s
                }
            }
            static resolve(e, t) {
                if (e instanceof this) return e.toJSON();
                if ("string" == typeof e.id && ["role", "member"].includes(e.type)) return {
                    ...e,
                    allow: r.resolve(e.allow),
                    deny: r.resolve(e.deny)
                };
                const s = t.roles.resolve(e.id) || t.client.users.resolve(e.id);
                if (!s) throw new n("INVALID_TYPE", "parameter", "User nor a Role", !0);
                const o = s instanceof i ? "role" : "member";
                return {
                    id: s.id,
                    type: o,
                    allow: r.resolve(e.allow),
                    deny: r.resolve(e.deny)
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(4);
        e.exports = class MessageAttachment {
            constructor(e, t = null, s) {
                this.attachment = e, this.name = t, s && this._patch(s)
            }
            setFile(e, t = null) {
                return this.attachment = e, this.name = t, this
            }
            setName(e) {
                return this.name = e, this
            }
            _patch(e) {
                this.id = e.id, this.size = e.size, this.url = e.url, this.proxyURL = e.proxy_url, this.height = void 0 !== e.height ? e.height : null, this.width = void 0 !== e.width ? e.width : null
            }
            get spoiler() {
                return i.basename(this.url).startsWith("SPOILER_")
            }
            toJSON() {
                return i.flatten(this)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const {
            RangeError: i
        } = s(3), n = s(4);
        e.exports = class MessageEmbed {
            constructor(e = {}, t = !1) {
                this.setup(e, t)
            }
            setup(e, t) {
                this.type = e.type, this.title = e.title, this.description = e.description, this.url = e.url, this.color = n.resolveColor(e.color), this.timestamp = e.timestamp ? new Date(e.timestamp).getTime() : null, this.fields = [], e.fields && (this.fields = t ? e.fields.map(n.cloneObject) : this.constructor.normalizeFields(e.fields)), this.thumbnail = e.thumbnail ? {
                    url: e.thumbnail.url,
                    proxyURL: e.thumbnail.proxyURL || e.thumbnail.proxy_url,
                    height: e.thumbnail.height,
                    width: e.thumbnail.width
                } : null, this.image = e.image ? {
                    url: e.image.url,
                    proxyURL: e.image.proxyURL || e.image.proxy_url,
                    height: e.image.height,
                    width: e.image.width
                } : null, this.video = e.video ? {
                    url: e.video.url,
                    proxyURL: e.video.proxyURL || e.video.proxy_url,
                    height: e.video.height,
                    width: e.video.width
                } : null, this.author = e.author ? {
                    name: e.author.name,
                    url: e.author.url,
                    iconURL: e.author.iconURL || e.author.icon_url,
                    proxyIconURL: e.author.proxyIconURL || e.author.proxy_icon_url
                } : null, this.provider = e.provider ? {
                    name: e.provider.name,
                    url: e.provider.name
                } : null, this.footer = e.footer ? {
                    text: e.footer.text,
                    iconURL: e.footer.iconURL || e.footer.icon_url,
                    proxyIconURL: e.footer.proxyIconURL || e.footer.proxy_icon_url
                } : null, this.files = e.files || []
            }
            get createdAt() {
                return this.timestamp ? new Date(this.timestamp) : null
            }
            get hexColor() {
                return this.color ? `#${this.color.toString(16).padStart(6,"0")}` : null
            }
            get length() {
                return (this.title ? this.title.length : 0) + (this.description ? this.description.length : 0) + (this.fields.length >= 1 ? this.fields.reduce((e, t) => e + t.name.length + t.value.length, 0) : 0) + (this.footer ? this.footer.text.length : 0)
            }
            addField(e, t, s) {
                return this.addFields({
                    name: e,
                    value: t,
                    inline: s
                })
            }
            addFields(...e) {
                return this.fields.push(...this.constructor.normalizeFields(e)), this
            }
            spliceFields(e, t, ...s) {
                return this.fields.splice(e, t, ...this.constructor.normalizeFields(...s)), this
            }
            attachFiles(e) {
                return this.files = this.files.concat(e), this
            }
            setAuthor(e, t, s) {
                return this.author = {
                    name: n.resolveString(e),
                    iconURL: t,
                    url: s
                }, this
            }
            setColor(e) {
                return this.color = n.resolveColor(e), this
            }
            setDescription(e) {
                return e = n.resolveString(e), this.description = e, this
            }
            setFooter(e, t) {
                return e = n.resolveString(e), this.footer = {
                    text: e,
                    iconURL: t
                }, this
            }
            setImage(e) {
                return this.image = {
                    url: e
                }, this
            }
            setThumbnail(e) {
                return this.thumbnail = {
                    url: e
                }, this
            }
            setTimestamp(e = Date.now()) {
                return e instanceof Date && (e = e.getTime()), this.timestamp = e, this
            }
            setTitle(e) {
                return e = n.resolveString(e), this.title = e, this
            }
            setURL(e) {
                return this.url = e, this
            }
            toJSON() {
                return {
                    title: this.title,
                    type: "rich",
                    description: this.description,
                    url: this.url,
                    timestamp: this.timestamp ? new Date(this.timestamp) : null,
                    color: this.color,
                    fields: this.fields,
                    thumbnail: this.thumbnail,
                    image: this.image,
                    author: this.author ? {
                        name: this.author.name,
                        url: this.author.url,
                        icon_url: this.author.iconURL
                    } : null,
                    footer: this.footer ? {
                        text: this.footer.text,
                        icon_url: this.footer.iconURL
                    } : null
                }
            }
            static normalizeField(e, t, s = !1) {
                if (!(e = n.resolveString(e))) throw new i("EMBED_FIELD_NAME");
                if (!(t = n.resolveString(t))) throw new i("EMBED_FIELD_VALUE");
                return {
                    name: e,
                    value: t,
                    inline: s
                }
            }
            static normalizeFields(...e) {
                return e.flat(2).map(e => this.normalizeField(e && e.name, e && e.value, !(!e || "boolean" != typeof e.inline) && e.inline))
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(14);
        class MessageFlags extends i {}
        MessageFlags.FLAGS = {
            CROSSPOSTED: 1,
            IS_CROSSPOST: 2,
            SUPPRESS_EMBEDS: 4,
            SOURCE_MESSAGE_DELETED: 8,
            URGENT: 16
        }, e.exports = MessageFlags
    }, function (e, t, s) {
        "use strict";
        const i = s(31);
        class WebhookClient extends i {
            constructor(e, t, s) {
                super(s), Object.defineProperty(this, "client", {
                    value: this
                }), this.id = e, Object.defineProperty(this, "token", {
                    value: t,
                    writable: !0,
                    configurable: !0
                })
            }
        }
        s(11).applyToClass(WebhookClient), e.exports = WebhookClient
    }, function (e, t, s) {
        "use strict";
        const i = s(24),
            n = s(2),
            r = s(4);
        e.exports = class Collector extends i {
            constructor(e, t, s = {}) {
                super(), Object.defineProperty(this, "client", {
                    value: e
                }), this.filter = t, this.options = s, this.collected = new n, this.ended = !1, this._timeout = null, this._idletimeout = null, this.handleCollect = this.handleCollect.bind(this), this.handleDispose = this.handleDispose.bind(this), s.time && (this._timeout = this.client.setTimeout(() => this.stop("time"), s.time)), s.idle && (this._idletimeout = this.client.setTimeout(() => this.stop("idle"), s.idle))
            }
            handleCollect(...e) {
                const t = this.collect(...e);
                t && this.filter(...e, this.collected) && (this.collected.set(t, e[0]), this.emit("collect", ...e), this._idletimeout && (this.client.clearTimeout(this._idletimeout), this._idletimeout = this.client.setTimeout(() => this.stop("idle"), this.options.idle))), this.checkEnd()
            }
            handleDispose(...e) {
                if (!this.options.dispose) return;
                const t = this.dispose(...e);
                t && this.filter(...e) && this.collected.has(t) && (this.collected.delete(t), this.emit("dispose", ...e), this.checkEnd())
            }
            get next() {
                return new Promise((e, t) => {
                    if (this.ended) return void t(this.collected);
                    const s = () => {
                            this.removeListener("collect", i), this.removeListener("end", n)
                        },
                        i = t => {
                            s(), e(t)
                        },
                        n = () => {
                            s(), t(this.collected)
                        };
                    this.on("collect", i), this.on("end", n)
                })
            }
            stop(e = "user") {
                this.ended || (this._timeout && (this.client.clearTimeout(this._timeout), this._timeout = null), this._idletimeout && (this.client.clearTimeout(this._idletimeout), this._idletimeout = null), this.ended = !0, this.emit("end", this.collected, e))
            }
            resetTimer({
                time: e,
                idle: t
            } = {}) {
                this._timeout && (this.client.clearTimeout(this._timeout), this._timeout = this.client.setTimeout(() => this.stop("time"), e || this.options.time)), this._idletimeout && (this.client.clearTimeout(this._idletimeout), this._idletimeout = this.client.setTimeout(() => this.stop("idle"), t || this.options.idle))
            }
            checkEnd() {
                const e = this.endReason();
                e && this.stop(e)
            }
            async *[Symbol.asyncIterator]() {
                const e = [],
                    t = t => e.push(t);
                this.on("collect", t);
                try {
                    for (; e.length || !this.ended;) e.length ? yield e.shift(): await new Promise(e => {
                        const t = () => (this.removeListener("collect", t), this.removeListener("end", t), e());
                        this.on("collect", t), this.on("end", t)
                    })
                } finally {
                    this.removeListener("collect", t)
                }
            }
            toJSON() {
                return r.flatten(this)
            }
            collect() {}
            dispose() {}
            endReason() {}
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            n = s(60),
            {
                ClientApplicationAssetTypes: r,
                Endpoints: o
            } = s(0),
            a = s(7),
            c = Object.keys(r);
        e.exports = class ClientApplication extends i {
            constructor(e, t) {
                super(e), this._patch(t)
            }
            _patch(e) {
                this.id = e.id, this.name = e.name, this.description = e.description, this.icon = e.icon, this.cover = e.cover_image || null, this.rpcOrigins = e.rpc_origins || [], this.botRequireCodeGrant = void 0 !== e.bot_require_code_grant ? e.bot_require_code_grant : null, this.botPublic = void 0 !== e.bot_public ? e.bot_public : null, this.owner = e.team ? new n(this.client, e.team) : e.owner ? this.client.users.add(e.owner) : null
            }
            get createdTimestamp() {
                return a.deconstruct(this.id).timestamp
            }
            get createdAt() {
                return new Date(this.createdTimestamp)
            }
            iconURL({
                format: e,
                size: t
            } = {}) {
                return this.icon ? this.client.rest.cdn.AppIcon(this.id, this.icon, {
                    format: e,
                    size: t
                }) : null
            }
            coverImage({
                format: e,
                size: t
            } = {}) {
                return this.cover ? o.CDN(this.client.options.http.cdn).AppIcon(this.id, this.cover, {
                    format: e,
                    size: t
                }) : null
            }
            fetchAssets() {
                return this.client.api.oauth2.applications(this.id).assets.get().then(e => e.map(e => ({
                    id: e.id,
                    name: e.name,
                    type: c[e.type - 1]
                })))
            }
            toString() {
                return this.name
            }
            toJSON() {
                return super.toJSON({
                    createdTimestamp: !0
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(19),
            n = s(43),
            r = s(64),
            o = s(4);
        e.exports = class MessageReaction {
            constructor(e, t, s) {
                Object.defineProperty(this, "client", {
                    value: e
                }), this.message = s, this.me = t.me, this.users = new r(e, void 0, this), this._emoji = new n(this, t.emoji), this._patch(t)
            }
            _patch(e) {
                null == this.count && (this.count = e.count)
            }
            async remove() {
                return await this.client.api.channels(this.message.channel.id).messages(this.message.id).reactions(this._emoji.identifier).delete(), this
            }
            get emoji() {
                if (this._emoji instanceof i) return this._emoji;
                if (this._emoji.id) {
                    const e = this.message.client.emojis.cache;
                    if (e.has(this._emoji.id)) {
                        const t = e.get(this._emoji.id);
                        return this._emoji = t, t
                    }
                }
                return this._emoji
            }
            get partial() {
                return null === this.count
            }
            async fetch() {
                const e = (await this.message.fetch()).reactions.cache.get(this.emoji.id || this.emoji.name);
                return this._patch(e || {
                    count: 0
                }), this
            }
            toJSON() {
                return o.flatten(this, {
                    emoji: "emojiID",
                    message: "messageID"
                })
            }
            _add(e) {
                this.partial || (this.users.cache.set(e.id, e), this.me && e.id === this.message.client.user.id && 0 !== this.count || this.count++, this.me || (this.me = e.id === this.message.client.user.id))
            }
            _remove(e) {
                this.partial || (this.users.cache.delete(e.id), this.me && e.id === this.message.client.user.id || this.count--, e.id === this.message.client.user.id && (this.me = !1), this.count <= 0 && 0 === this.users.cache.size && this.message.reactions.cache.delete(this.emoji.id || this.emoji.name))
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(25),
            n = s(4);
        e.exports = class ReactionEmoji extends i {
            constructor(e, t) {
                super(e.message.client, t), this.reaction = e
            }
            toJSON() {
                return n.flatten(this, {
                    identifier: !0
                })
            }
            valueOf() {
                return this.id
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            n = s(69),
            r = s(46),
            o = s(45),
            a = s(16),
            c = s(47),
            l = s(11),
            h = s(70),
            u = s(48),
            d = s(71),
            p = s(72),
            m = s(73),
            g = s(108),
            E = s(2),
            {
                ChannelTypes: f,
                DefaultMessageNotifications: _,
                PartialTypes: I,
                VerificationLevels: A,
                ExplicitContentFilterLevels: y
            } = s(0),
            v = s(9),
            D = s(7),
            T = s(74),
            b = s(4);
        e.exports = class Guild extends i {
            constructor(e, t) {
                super(e), this.members = new d(this), this.channels = new h(this), this.roles = new m(this), this.presences = new p(this.client), this.voiceStates = new g(this), this.deleted = !1, t && (t.unavailable ? (this.available = !1, this.id = t.id) : (this._patch(t), t.channels || (this.available = !1)), this.shardID = t.shardID)
            }
            get shard() {
                return this.client.ws.shards.get(this.shardID)
            }
            _patch(e) {
                if (this.name = e.name, this.icon = e.icon, this.splash = e.splash, this.region = e.region, this.memberCount = e.member_count || this.memberCount, this.large = Boolean("large" in e ? e.large : this.large), this.features = e.features, this.applicationID = e.application_id, this.afkTimeout = e.afk_timeout, this.afkChannelID = e.afk_channel_id, this.systemChannelID = e.system_channel_id, this.embedEnabled = e.embed_enabled, this.premiumTier = e.premium_tier, void 0 !== e.premium_subscription_count && (this.premiumSubscriptionCount = e.premium_subscription_count), void 0 !== e.widget_enabled && (this.widgetEnabled = e.widget_enabled), void 0 !== e.widget_channel_id && (this.widgetChannelID = e.widget_channel_id), void 0 !== e.embed_channel_id && (this.embedChannelID = e.embed_channel_id), this.verificationLevel = A[e.verification_level], this.explicitContentFilter = y[e.explicit_content_filter], this.mfaLevel = e.mfa_level, this.joinedTimestamp = e.joined_at ? new Date(e.joined_at).getTime() : this.joinedTimestamp, this.defaultMessageNotifications = _[e.default_message_notifications] || e.default_message_notifications, this.systemChannelFlags = new T(e.system_channel_flags).freeze(), void 0 !== e.max_members && (this.maximumMembers = e.max_members || 25e4), void 0 !== e.max_presences && (this.maximumPresences = e.max_presences || 25e3), this.vanityURLCode = e.vanity_url_code, this.description = e.description, this.banner = e.banner, this.id = e.id, this.available = !e.unavailable, this.features = e.features || this.features || [], this.rulesChannelID = e.rules_channel_id, this.publicUpdatesChannelID = e.public_updates_channel_id, e.channels) {
                    this.channels.cache.clear();
                    for (const t of e.channels) this.client.channels.add(t, this)
                }
                if (e.roles) {
                    this.roles.cache.clear();
                    for (const t of e.roles) this.roles.add(t)
                }
                if (e.members) {
                    this.members.cache.clear();
                    for (const t of e.members) this.members.add(t)
                }
                if (e.owner_id && (this.ownerID = e.owner_id), e.presences)
                    for (const t of e.presences) this.presences.add(Object.assign(t, {
                        guild: this
                    }));
                if (e.voice_states) {
                    this.voiceStates.cache.clear();
                    for (const t of e.voice_states) this.voiceStates.add(t)
                }
                if (this.emojis) e.emojis && this.client.actions.GuildEmojisUpdate.handle({
                    guild_id: this.id,
                    emojis: e.emojis
                });
                else if (this.emojis = new u(this), e.emojis)
                    for (const t of e.emojis) this.emojis.add(t)
            }
            bannerURL({
                format: e,
                size: t
            } = {}) {
                return this.banner ? this.client.rest.cdn.Banner(this.id, this.banner, e, t) : null
            }
            get createdTimestamp() {
                return D.deconstruct(this.id).timestamp
            }
            get createdAt() {
                return new Date(this.createdTimestamp)
            }
            get joinedAt() {
                return new Date(this.joinedTimestamp)
            }
            get partnered() {
                return this.features.includes("PARTNERED")
            }
            get verified() {
                return this.features.includes("VERIFIED")
            }
            iconURL({
                format: e,
                size: t,
                dynamic: s
            } = {}) {
                return this.icon ? this.client.rest.cdn.Icon(this.id, this.icon, e, t, s) : null
            }
            get nameAcronym() {
                return this.name.replace(/\w+/g, e => e[0]).replace(/\s/g, "")
            }
            splashURL({
                format: e,
                size: t
            } = {}) {
                return this.splash ? this.client.rest.cdn.Splash(this.id, this.splash, e, t) : null
            }
            get owner() {
                return this.members.cache.get(this.ownerID) || (this.client.options.partials.includes(I.GUILD_MEMBER) ? this.members.add({
                    user: {
                        id: this.ownerID
                    }
                }, !0) : null)
            }
            get afkChannel() {
                return this.client.channels.cache.get(this.afkChannelID) || null
            }
            get systemChannel() {
                return this.client.channels.cache.get(this.systemChannelID) || null
            }
            get widgetChannel() {
                return this.client.channels.cache.get(this.widgetChannelID) || null
            }
            get embedChannel() {
                return this.client.channels.cache.get(this.embedChannelID) || null
            }
            get rulesChannel() {
                return this.client.channels.cache.get(this.rulesChannelID) || null
            }
            get publicUpdatesChannel() {
                return this.client.channels.cache.get(this.publicUpdatesChannelID) || null
            }
            get me() {
                return this.members.cache.get(this.client.user.id) || (this.client.options.partials.includes(I.GUILD_MEMBER) ? this.members.add({
                    user: {
                        id: this.client.user.id
                    }
                }, !0) : null)
            }
            get voice() {
                return this.voiceStates.cache.get(this.client.user.id)
            }
            member(e) {
                return this.members.resolve(e)
            }
            fetch() {
                return this.client.api.guilds(this.id).get().then(e => (this._patch(e), this))
            }
            fetchBan(e) {
                const t = this.client.users.resolveID(e);
                if (!t) throw new Error("FETCH_BAN_RESOLVE_ID");
                return this.client.api.guilds(this.id).bans(t).get().then(e => ({
                    reason: e.reason,
                    user: this.client.users.add(e.user)
                }))
            }
            fetchBans() {
                return this.client.api.guilds(this.id).bans.get().then(e => e.reduce((e, t) => (e.set(t.user.id, {
                    reason: t.reason,
                    user: this.client.users.add(t.user)
                }), e), new E))
            }
            fetchIntegrations() {
                return this.client.api.guilds(this.id).integrations.get().then(e => e.reduce((e, t) => e.set(t.id, new o(this.client, t, this)), new E))
            }
            createIntegration(e, t) {
                return this.client.api.guilds(this.id).integrations.post({
                    data: e,
                    reason: t
                }).then(() => this)
            }
            fetchInvites() {
                return this.client.api.guilds(this.id).invites.get().then(e => {
                    const t = new E;
                    for (const s of e) {
                        const e = new a(this.client, s);
                        t.set(e.code, e)
                    }
                    return t
                })
            }
            fetchPreview() {
                return this.client.api.guilds(this.id).preview.get().then(e => new r(this.client, e))
            }
            fetchVanityCode() {
                return this.features.includes("VANITY_URL") ? this.client.api.guilds(this.id, "vanity-url").get().then(e => e.code) : Promise.reject(new Error("VANITY_URL"))
            }
            fetchWebhooks() {
                return this.client.api.guilds(this.id).webhooks.get().then(e => {
                    const t = new E;
                    for (const s of e) t.set(s.id, new l(this.client, s));
                    return t
                })
            }
            fetchVoiceRegions() {
                return this.client.api.guilds(this.id).regions.get().then(e => {
                    const t = new E;
                    for (const s of e) t.set(s.id, new c(s));
                    return t
                })
            }
            fetchEmbed() {
                return this.client.api.guilds(this.id).embed.get().then(e => ({
                    enabled: e.enabled,
                    channel: e.channel_id ? this.channels.cache.get(e.channel_id) : null
                }))
            }
            fetchAuditLogs(e = {}) {
                return e.before && e.before instanceof n.Entry && (e.before = e.before.id), "string" == typeof e.type && (e.type = n.Actions[e.type]), this.client.api.guilds(this.id)["audit-logs"].get({
                    query: {
                        before: e.before,
                        limit: e.limit,
                        user_id: this.client.users.resolveID(e.user),
                        action_type: e.type
                    }
                }).then(e => n.build(this, e))
            }
            addMember(e, t) {
                if (!(e = this.client.users.resolveID(e))) return Promise.reject(new TypeError("INVALID_TYPE", "user", "UserResolvable"));
                if (this.members.cache.has(e)) return Promise.resolve(this.members.cache.get(e));
                if (t.access_token = t.accessToken, t.roles) {
                    const e = [];
                    for (let s of t.roles instanceof E ? t.roles.values() : t.roles) {
                        if (s = this.roles.resolve(s), !s) return Promise.reject(new TypeError("INVALID_TYPE", "options.roles", "Array or Collection of Roles or Snowflakes", !0));
                        e.push(s.id)
                    }
                    t.roles = e
                }
                return this.client.api.guilds(this.id).members(e).put({
                    data: t
                }).then(e => this.members.add(e))
            }
            edit(e, t) {
                const s = {};
                return e.name && (s.name = e.name), e.region && (s.region = e.region), void 0 !== e.verificationLevel && (s.verification_level = "number" == typeof e.verificationLevel ? Number(e.verificationLevel) : A.indexOf(e.verificationLevel)), void 0 !== e.afkChannel && (s.afk_channel_id = this.client.channels.resolveID(e.afkChannel)), void 0 !== e.systemChannel && (s.system_channel_id = this.client.channels.resolveID(e.systemChannel)), e.afkTimeout && (s.afk_timeout = Number(e.afkTimeout)), void 0 !== e.icon && (s.icon = e.icon), e.owner && (s.owner_id = this.client.users.resolveID(e.owner)), e.splash && (s.splash = e.splash), e.banner && (s.banner = e.banner), void 0 !== e.explicitContentFilter && (s.explicit_content_filter = "number" == typeof e.explicitContentFilter ? e.explicitContentFilter : y.indexOf(e.explicitContentFilter)), void 0 !== e.defaultMessageNotifications && (s.default_message_notifications = "string" == typeof e.defaultMessageNotifications ? _.indexOf(e.defaultMessageNotifications) : e.defaultMessageNotifications), void 0 !== e.systemChannelFlags && (s.system_channel_flags = T.resolve(e.systemChannelFlags)), this.client.api.guilds(this.id).patch({
                    data: s,
                    reason: t
                }).then(e => this.client.actions.GuildUpdate.handle(e).updated)
            }
            setExplicitContentFilter(e, t) {
                return this.edit({
                    explicitContentFilter: e
                }, t)
            }
            setDefaultMessageNotifications(e, t) {
                return this.edit({
                    defaultMessageNotifications: e
                }, t)
            }
            setSystemChannelFlags(e, t) {
                return this.edit({
                    systemChannelFlags: e
                }, t)
            }
            setName(e, t) {
                return this.edit({
                    name: e
                }, t)
            }
            setRegion(e, t) {
                return this.edit({
                    region: e
                }, t)
            }
            setVerificationLevel(e, t) {
                return this.edit({
                    verificationLevel: e
                }, t)
            }
            setAFKChannel(e, t) {
                return this.edit({
                    afkChannel: e
                }, t)
            }
            setSystemChannel(e, t) {
                return this.edit({
                    systemChannel: e
                }, t)
            }
            setAFKTimeout(e, t) {
                return this.edit({
                    afkTimeout: e
                }, t)
            }
            async setIcon(e, t) {
                return this.edit({
                    icon: await v.resolveImage(e),
                    reason: t
                })
            }
            setOwner(e, t) {
                return this.edit({
                    owner: e
                }, t)
            }
            async setSplash(e, t) {
                return this.edit({
                    splash: await v.resolveImage(e),
                    reason: t
                })
            }
            async setBanner(e, t) {
                return this.edit({
                    banner: await v.resolveImage(e),
                    reason: t
                })
            }
            setChannelPositions(e) {
                const t = e.map(e => ({
                    id: this.client.channels.resolveID(e.channel),
                    position: e.position
                }));
                return this.client.api.guilds(this.id).channels.patch({
                    data: t
                }).then(() => this.client.actions.GuildChannelsPositionUpdate.handle({
                    guild_id: this.id,
                    channels: t
                }).guild)
            }
            setRolePositions(e) {
                return e = e.map(e => ({
                    id: this.roles.resolveID(e.role),
                    position: e.position
                })), this.client.api.guilds(this.id).roles.patch({
                    data: e
                }).then(() => this.client.actions.GuildRolesPositionUpdate.handle({
                    guild_id: this.id,
                    roles: e
                }).guild)
            }
            setEmbed(e, t) {
                return this.client.api.guilds(this.id).embed.patch({
                    data: {
                        enabled: e.enabled,
                        channel_id: this.channels.resolveID(e.channel)
                    },
                    reason: t
                }).then(() => this)
            }
            leave() {
                return this.ownerID === this.client.user.id ? Promise.reject(new Error("GUILD_OWNED")) : this.client.api.users("@me").guilds(this.id).delete().then(() => this.client.actions.GuildDelete.handle({
                    id: this.id
                }).guild)
            }
            delete() {
                return this.client.api.guilds(this.id).delete().then(() => this.client.actions.GuildDelete.handle({
                    id: this.id
                }).guild)
            }
            equals(e) {
                let t = e && e instanceof this.constructor && this.id === e.id && this.available === e.available && this.splash === e.splash && this.region === e.region && this.name === e.name && this.memberCount === e.memberCount && this.large === e.large && this.icon === e.icon && this.ownerID === e.ownerID && this.verificationLevel === e.verificationLevel && this.embedEnabled === e.embedEnabled && (this.features === e.features || this.features.length === e.features.length && this.features.every((t, s) => t === e.features[s]));
                return t && (this.embedChannel ? e.embedChannel && this.embedChannel.id === e.embedChannel.id || (t = !1) : e.embedChannel && (t = !1)), t
            }
            toString() {
                return this.name
            }
            toJSON() {
                const e = super.toJSON({
                    available: !1,
                    createdTimestamp: !0,
                    nameAcronym: !0,
                    presences: !1,
                    voiceStates: !1
                });
                return e.iconURL = this.iconURL(), e.splashURL = this.splashURL(), e.bannerURL = this.bannerURL(), e
            }
            _sortedRoles() {
                return b.discordSort(this.roles.cache)
            }
            _sortedChannels(e) {
                const t = e.type === f.CATEGORY;
                return b.discordSort(this.channels.cache.filter(s => s.type === e.type && (t || s.parent === e.parent)))
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(5);
        e.exports = class Integration extends i {
            constructor(e, t, s) {
                super(e), this.guild = s, this.id = t.id, this.name = t.name, this.type = t.type, this.enabled = t.enabled, this.syncing = t.syncing, this.role = this.guild.roles.cache.get(t.role_id), this.user = this.client.users.add(t.user), this.account = t.account, this.syncedAt = t.synced_at, this._patch(t)
            }
            _patch(e) {
                this.expireBehavior = e.expire_behavior, this.expireGracePeriod = e.expire_grace_period
            }
            sync() {
                return this.syncing = !0, this.client.api.guilds(this.guild.id).integrations(this.id).post().then(() => (this.syncing = !1, this.syncedAt = Date.now(), this))
            }
            edit(e, t) {
                return "expireBehavior" in e && (e.expire_behavior = e.expireBehavior, e.expireBehavior = null), "expireGracePeriod" in e && (e.expire_grace_period = e.expireGracePeriod, e.expireGracePeriod = null), this.client.api.guilds(this.guild.id).integrations(this.id).patch({
                    data: e,
                    reason: t
                }).then(() => (this._patch(e), this))
            }
            delete(e) {
                return this.client.api.guilds(this.guild.id).integrations(this.id).delete({
                    reason: e
                }).then(() => this)
            }
            toJSON() {
                return super.toJSON({
                    role: "roleID",
                    guild: "guildID",
                    user: "userID"
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            n = s(107),
            r = s(2);
        e.exports = class GuildPreview extends i {
            constructor(e, t) {
                super(e), t && this._patch(t)
            }
            _patch(e) {
                this.id = e.id, this.name = e.name, this.icon = e.icon, this.splash = e.splash, this.discoverySplash = e.discovery_splash, this.features = e.features, this.approximateMemberCount = e.approximate_member_count, this.approximatePresenceCount = e.approximate_presence_count, this.description = e.description, this.emojis ? this.emojis.clear() : this.emojis = new r;
                for (const t of e.emojis) this.emojis.set(t.id, new n(this.client, t, this))
            }
            splashURL({
                format: e,
                size: t
            } = {}) {
                return this.splash ? this.client.rest.cdn.Splash(this.id, this.splash, e, t) : null
            }
            discoverySplashURL({
                format: e,
                size: t
            } = {}) {
                return this.discoverySplash ? this.client.rest.cdn.DiscoverySplash(this.id, this.discoverySplash, e, t) : null
            }
            iconURL({
                format: e,
                size: t,
                dynamic: s
            } = {}) {
                return this.icon ? this.client.rest.cdn.Icon(this.id, this.icon, e, t, s) : null
            }
            fetch() {
                return this.client.api.guilds(this.id).preview.get().then(e => (this._patch(e), this))
            }
            toString() {
                return this.name
            }
            toJSON() {
                const e = super.toJSON();
                return e.iconURL = this.iconURL(), e.splashURL = this.splashURL(), e
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(4);
        e.exports = class VoiceRegion {
            constructor(e) {
                this.id = e.id, this.name = e.name, this.vip = e.vip, this.deprecated = e.deprecated, this.optimal = e.optimal, this.custom = e.custom
            }
            toJSON() {
                return i.flatten(this)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            {
                TypeError: n
            } = s(3),
            r = s(19),
            o = s(43),
            a = s(2),
            c = s(9);
        e.exports = class GuildEmojiManager extends i {
            constructor(e, t) {
                super(e.client, t, r), this.guild = e
            }
            add(e, t) {
                return super.add(e, t, {
                    extras: [this.guild]
                })
            }
            async create(e, t, {
                roles: s,
                reason: i
            } = {}) {
                if (!(e = await c.resolveImage(e))) throw new n("REQ_RESOURCE_TYPE");
                const r = {
                    image: e,
                    name: t
                };
                if (s) {
                    r.roles = [];
                    for (let e of s instanceof a ? s.values() : s) {
                        if (e = this.guild.roles.resolve(e), !e) return Promise.reject(new n("INVALID_TYPE", "options.roles", "Array or Collection of Roles or Snowflakes", !0));
                        r.roles.push(e.id)
                    }
                }
                return this.client.api.guilds(this.guild.id).emojis.post({
                    data: r,
                    reason: i
                }).then(e => this.client.actions.GuildEmojiCreate.handle(this.guild, e).emoji)
            }
            resolve(e) {
                return e instanceof o ? super.resolve(e.id) : super.resolve(e)
            }
            resolveID(e) {
                return e instanceof o ? e.id : super.resolveID(e)
            }
            resolveIdentifier(e) {
                const t = this.resolve(e);
                return t ? t.identifier : e instanceof o ? e.identifier : "string" == typeof e ? e.includes("%") ? e : encodeURIComponent(e) : null
            }
        }
    }, function (e, t) {
        e.exports = {
            version: "12.1.1",
            homepage: "https://github.com/discordjs/discord.js#readme"
        }
    }, function (e, t, s) {
        "use strict";
        const i = Symbol("code"),
            n = new Map;

        function r(e) {
            return class DiscordjsError extends e {
                constructor(e, ...t) {
                    super(function (e, t) {
                        if ("string" != typeof e) throw new Error("Error message key must be a string");
                        const s = n.get(e);
                        if (!s) throw new Error(`An invalid error message key was used: ${e}.`);
                        return "function" == typeof s ? s(...t) : void 0 === t || 0 === t.length ? s : (t.unshift(s), String(...t))
                    }(e, t)), this[i] = e, Error.captureStackTrace && Error.captureStackTrace(this, DiscordjsError)
                }
                get name() {
                    return `${super.name} [${this[i]}]`
                }
                get code() {
                    return this[i]
                }
            }
        }
        e.exports = {
            register: function (e, t) {
                n.set(e, "function" == typeof t ? t : String(t))
            },
            Error: r(Error),
            TypeError: r(TypeError),
            RangeError: r(RangeError)
        }
    }, function (e, t, s) {
        (function (e) {
            var i = void 0 !== e && e || "undefined" != typeof self && self || window,
                n = Function.prototype.apply;

            function r(e, t) {
                this._id = e, this._clearFn = t
            }
            t.setTimeout = function () {
                return new r(n.call(setTimeout, i, arguments), clearTimeout)
            }, t.setInterval = function () {
                return new r(n.call(setInterval, i, arguments), clearInterval)
            }, t.clearTimeout = t.clearInterval = function (e) {
                e && e.close()
            }, r.prototype.unref = r.prototype.ref = function () {}, r.prototype.close = function () {
                this._clearFn.call(i, this._id)
            }, t.enroll = function (e, t) {
                clearTimeout(e._idleTimeoutId), e._idleTimeout = t
            }, t.unenroll = function (e) {
                clearTimeout(e._idleTimeoutId), e._idleTimeout = -1
            }, t._unrefActive = t.active = function (e) {
                clearTimeout(e._idleTimeoutId);
                var t = e._idleTimeout;
                t >= 0 && (e._idleTimeoutId = setTimeout((function () {
                    e._onTimeout && e._onTimeout()
                }), t))
            }, s(53), t.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== e && e.setImmediate || this && this.setImmediate, t.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== e && e.clearImmediate || this && this.clearImmediate
        }).call(this, s(52))
    }, function (e, t) {
        var s;
        s = function () {
            return this
        }();
        try {
            s = s || new Function("return this")()
        } catch (e) {
            "object" == typeof window && (s = window)
        }
        e.exports = s
    }, function (e, t, s) {
        (function (e, t) {
            ! function (e, s) {
                "use strict";
                if (!e.setImmediate) {
                    var i, n, r, o, a, c = 1,
                        l = {},
                        h = !1,
                        u = e.document,
                        d = Object.getPrototypeOf && Object.getPrototypeOf(e);
                    d = d && d.setTimeout ? d : e, "[object process]" === {}.toString.call(e.process) ? i = function (e) {
                        t.nextTick((function () {
                            m(e)
                        }))
                    } : ! function () {
                        if (e.postMessage && !e.importScripts) {
                            var t = !0,
                                s = e.onmessage;
                            return e.onmessage = function () {
                                t = !1
                            }, e.postMessage("", "*"), e.onmessage = s, t
                        }
                    }() ? e.MessageChannel ? ((r = new MessageChannel).port1.onmessage = function (e) {
                        m(e.data)
                    }, i = function (e) {
                        r.port2.postMessage(e)
                    }) : u && "onreadystatechange" in u.createElement("script") ? (n = u.documentElement, i = function (e) {
                        var t = u.createElement("script");
                        t.onreadystatechange = function () {
                            m(e), t.onreadystatechange = null, n.removeChild(t), t = null
                        }, n.appendChild(t)
                    }) : i = function (e) {
                        setTimeout(m, 0, e)
                    } : (o = "setImmediate$" + Math.random() + "$", a = function (t) {
                        t.source === e && "string" == typeof t.data && 0 === t.data.indexOf(o) && m(+t.data.slice(o.length))
                    }, e.addEventListener ? e.addEventListener("message", a, !1) : e.attachEvent("onmessage", a), i = function (t) {
                        e.postMessage(o + t, "*")
                    }), d.setImmediate = function (e) {
                        "function" != typeof e && (e = new Function("" + e));
                        for (var t = new Array(arguments.length - 1), s = 0; s < t.length; s++) t[s] = arguments[s + 1];
                        var n = {
                            callback: e,
                            args: t
                        };
                        return l[c] = n, i(c), c++
                    }, d.clearImmediate = p
                }

                function p(e) {
                    delete l[e]
                }

                function m(e) {
                    if (h) setTimeout(m, 0, e);
                    else {
                        var t = l[e];
                        if (t) {
                            h = !0;
                            try {
                                ! function (e) {
                                    var t = e.callback,
                                        s = e.args;
                                    switch (s.length) {
                                        case 0:
                                            t();
                                            break;
                                        case 1:
                                            t(s[0]);
                                            break;
                                        case 2:
                                            t(s[0], s[1]);
                                            break;
                                        case 3:
                                            t(s[0], s[1], s[2]);
                                            break;
                                        default:
                                            t.apply(void 0, s)
                                    }
                                }(t)
                            } finally {
                                p(e), h = !1
                            }
                        }
                    }
                }
            }("undefined" == typeof self ? void 0 === e ? this : e : self)
        }).call(this, s(52), s(23))
    }, function (e, t, s) {
        "use strict";
        class DiscordAPIError extends Error {
            constructor(e, t, s, i) {
                super();
                const n = this.constructor.flattenErrors(t.errors || t).join("\n");
                this.name = "DiscordAPIError", this.message = t.message && n ? `${t.message}\n${n}` : t.message || n, this.method = s, this.path = e, this.code = t.code, this.httpStatus = i
            }
            static flattenErrors(e, t = "") {
                let s = [];
                for (const [i, n] of Object.entries(e)) {
                    if ("message" === i) continue;
                    const e = t ? isNaN(i) ? `${t}.${i}` : `${t}[${i}]` : i;
                    n._errors ? s.push(`${e}: ${n._errors.map(e=>e.message).join(" ")}`) : n.code || n.message ? s.push(`${n.code?`${n.code}: `:""}${n.message}`.trim()) : "string" == typeof n ? s.push(n) : s = s.concat(this.flattenErrors(n, e))
                }
                return s
            }
        }
        e.exports = DiscordAPIError
    }, function (e, t, s) {
        "use strict";
        class HTTPError extends Error {
            constructor(e, t, s, i, n) {
                super(e), this.name = t, this.code = s || 500, this.method = i, this.path = n
            }
        }
        e.exports = HTTPError
    }, function (e, t, s) {
        "use strict";
        const {
            TypeError: i
        } = s(3), n = s(2);
        e.exports = class GuildEmojiRoleManager {
            constructor(e) {
                this.emoji = e, this.guild = e.guild, Object.defineProperty(this, "client", {
                    value: e.client
                })
            }
            get _roles() {
                return this.guild.roles.cache.filter(e => this.emoji._roles.includes(e.id))
            }
            get cache() {
                return this._roles
            }
            add(e) {
                if (e instanceof n) return this.add(e.keyArray());
                if (!Array.isArray(e)) return this.add([e]);
                if ((e = e.map(e => this.guild.roles.resolve(e))).includes(null)) return Promise.reject(new i("INVALID_TYPE", "roles", "Array or Collection of Roles or Snowflakes", !0));
                const t = [...new Set(e.concat(...this._roles.values()))];
                return this.set(t)
            }
            remove(e) {
                if (e instanceof n) return this.remove(e.keyArray());
                if (!Array.isArray(e)) return this.remove([e]);
                if ((e = e.map(e => this.guild.roles.resolveID(e))).includes(null)) return Promise.reject(new i("INVALID_TYPE", "roles", "Array or Collection of Roles or Snowflakes", !0));
                const t = this._roles.keyArray().filter(t => !e.includes(t));
                return this.set(t)
            }
            set(e) {
                return this.emoji.edit({
                    roles: e
                })
            }
            clone() {
                const e = new this.constructor(this.emoji);
                return e._patch(this._roles.keyArray().slice()), e
            }
            _patch(e) {
                this.emoji._roles = e
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(14);
        class ActivityFlags extends i {}
        ActivityFlags.FLAGS = {
            INSTANCE: 1,
            JOIN: 2,
            SPECTATE: 4,
            JOIN_REQUEST: 8,
            SYNC: 16,
            PLAY: 32
        }, e.exports = ActivityFlags
    }, function (e, t, s) {
        "use strict";
        const i = s(40),
            {
                Events: n
            } = s(0);
        e.exports = class MessageCollector extends i {
            constructor(e, t, s = {}) {
                super(e.client, t, s), this.channel = e, this.received = 0;
                const i = e => {
                    for (const t of e.values()) this.handleDispose(t)
                };
                this._handleChannelDeletion = this._handleChannelDeletion.bind(this), this._handleGuildDeletion = this._handleGuildDeletion.bind(this), 0 !== this.client.getMaxListeners() && this.client.setMaxListeners(this.client.getMaxListeners() + 1), this.client.on(n.MESSAGE_CREATE, this.handleCollect), this.client.on(n.MESSAGE_DELETE, this.handleDispose), this.client.on(n.MESSAGE_BULK_DELETE, i), this.client.on(n.CHANNEL_DELETE, this._handleChannelDeletion), this.client.on(n.GUILD_DELETE, this._handleGuildDeletion), this.once("end", () => {
                    this.client.removeListener(n.MESSAGE_CREATE, this.handleCollect), this.client.removeListener(n.MESSAGE_DELETE, this.handleDispose), this.client.removeListener(n.MESSAGE_BULK_DELETE, i), this.client.removeListener(n.CHANNEL_DELETE, this._handleChannelDeletion), this.client.removeListener(n.GUILD_DELETE, this._handleGuildDeletion), 0 !== this.client.getMaxListeners() && this.client.setMaxListeners(this.client.getMaxListeners() - 1)
                })
            }
            collect(e) {
                return e.channel.id !== this.channel.id ? null : (this.received++, e.id)
            }
            dispose(e) {
                return e.channel.id === this.channel.id ? e.id : null
            }
            endReason() {
                return this.options.max && this.collected.size >= this.options.max ? "limit" : this.options.maxProcessed && this.received === this.options.maxProcessed ? "processedLimit" : null
            }
            _handleChannelDeletion(e) {
                e.id === this.channel.id && this.stop("channelDelete")
            }
            _handleGuildDeletion(e) {
                this.channel.guild && e.id === this.channel.guild.id && this.stop("guildDelete")
            }
        }
    }, function (e, t, s) {
        "use strict";
        const {
            TypeError: i
        } = s(3), n = s(2);
        e.exports = class GuildMemberRoleManager {
            constructor(e) {
                this.member = e, this.guild = e.guild, Object.defineProperty(this, "client", {
                    value: e.client
                })
            }
            get _roles() {
                const e = this.guild.roles.everyone;
                return this.guild.roles.cache.filter(e => this.member._roles.includes(e.id)).set(e.id, e)
            }
            get cache() {
                return this._roles
            }
            get hoist() {
                const e = this._roles.filter(e => e.hoist);
                return e.size ? e.reduce((e, t) => !e || t.comparePositionTo(e) > 0 ? t : e) : null
            }
            get color() {
                const e = this._roles.filter(e => e.color);
                return e.size ? e.reduce((e, t) => !e || t.comparePositionTo(e) > 0 ? t : e) : null
            }
            get highest() {
                return this._roles.reduce((e, t) => t.comparePositionTo(e) > 0 ? t : e, this._roles.first())
            }
            async add(e, t) {
                if (e instanceof n || Array.isArray(e)) {
                    if ((e = e.map(e => this.guild.roles.resolve(e))).includes(null)) throw new i("INVALID_TYPE", "roles", "Array or Collection of Roles or Snowflakes", !0);
                    const s = [...new Set(e.concat(...this._roles.values()))];
                    return this.set(s, t)
                } {
                    if (null === (e = this.guild.roles.resolve(e))) throw new i("INVALID_TYPE", "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes", !0);
                    await this.client.api.guilds[this.guild.id].members[this.member.id].roles[e.id].put({
                        reason: t
                    });
                    const s = this.member._clone();
                    return s._roles = [...this._roles.keys(), e.id], s
                }
            }
            async remove(e, t) {
                if (e instanceof n || Array.isArray(e)) {
                    if ((e = e.map(e => this.guild.roles.resolve(e))).includes(null)) throw new i("INVALID_TYPE", "roles", "Array or Collection of Roles or Snowflakes", !0);
                    const s = this._roles.filter(t => !e.includes(t));
                    return this.set(s, t)
                } {
                    if (null === (e = this.guild.roles.resolve(e))) throw new i("INVALID_TYPE", "roles", "Array or Collection of Roles or Snowflakes", !0);
                    await this.client.api.guilds[this.guild.id].members[this.member.id].roles[e.id].delete({
                        reason: t
                    });
                    const s = this.member._clone(),
                        n = this._roles.filter(t => t.id !== e.id);
                    return s._roles = [...n.keys()], s
                }
            }
            set(e, t) {
                return this.member.edit({
                    roles: e
                }, t)
            }
            clone() {
                const e = new this.constructor(this.member);
                return e.member._roles = [...this._roles.keyArray()], e
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            n = s(61),
            r = s(2),
            o = s(7);
        e.exports = class Team extends i {
            constructor(e, t) {
                super(e), this._patch(t)
            }
            _patch(e) {
                this.id = e.id, this.name = e.name, this.icon = e.icon || null, this.ownerID = e.owner_user_id || null, this.members = new r;
                for (const t of e.members) {
                    const e = new n(this, t);
                    this.members.set(e.id, e)
                }
            }
            get owner() {
                return this.members.get(this.ownerID) || null
            }
            get createdTimestamp() {
                return o.deconstruct(this.id).timestamp
            }
            get createdAt() {
                return new Date(this.createdTimestamp)
            }
            iconURL({
                format: e,
                size: t
            } = {}) {
                return this.icon ? this.client.rest.cdn.TeamIcon(this.id, this.icon, {
                    format: e,
                    size: t
                }) : null
            }
            toString() {
                return this.name
            }
            toJSON() {
                return super.toJSON({
                    createdTimestamp: !0
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(5),
            {
                MembershipStates: n
            } = s(0);
        e.exports = class TeamMember extends i {
            constructor(e, t) {
                super(e.client), this.team = e, this._patch(t)
            }
            _patch(e) {
                this.permissions = e.permissions, this.membershipState = n[e.membership_state], this.user = this.client.users.add(e.user)
            }
            get id() {
                return this.user.id
            }
            toString() {
                return this.user.toString()
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(2),
            {
                ChannelTypes: n
            } = s(0),
            r = s(4);
        class MessageMentions {
            constructor(e, t, s, r, o) {
                if (Object.defineProperty(this, "client", {
                        value: e.client
                    }), Object.defineProperty(this, "guild", {
                        value: e.guild
                    }), Object.defineProperty(this, "_content", {
                        value: e.content
                    }), this.everyone = Boolean(r), t)
                    if (t instanceof i) this.users = new i(t);
                    else {
                        this.users = new i;
                        for (const s of t) {
                            s.member && e.guild && e.guild.members.add(Object.assign(s.member, {
                                user: s
                            }));
                            const t = e.client.users.add(s);
                            this.users.set(t.id, t)
                        }
                    }
                else this.users = new i;
                if (s)
                    if (s instanceof i) this.roles = new i(s);
                    else {
                        this.roles = new i;
                        for (const t of s) {
                            const s = e.channel.guild.roles.cache.get(t);
                            s && this.roles.set(s.id, s)
                        }
                    }
                else this.roles = new i;
                if (this._members = null, this._channels = null, o)
                    if (o instanceof i) this.crosspostedChannels = new i(o);
                    else {
                        this.crosspostedChannels = new i;
                        const e = Object.keys(n);
                        for (const t of o) {
                            const s = e[t.type];
                            this.crosspostedChannels.set(t.id, {
                                channelID: t.id,
                                guildID: t.guild_id,
                                type: s ? s.toLowerCase() : "unknown",
                                name: t.name
                            })
                        }
                    }
                else this.crosspostedChannels = new i
            }
            get members() {
                return this._members ? this._members : this.guild ? (this._members = new i, this.users.forEach(e => {
                    const t = this.guild.member(e);
                    t && this._members.set(t.user.id, t)
                }), this._members) : null
            }
            get channels() {
                if (this._channels) return this._channels;
                let e;
                for (this._channels = new i; null !== (e = this.constructor.CHANNELS_PATTERN.exec(this._content));) {
                    const t = this.client.channels.cache.get(e[1]);
                    t && this._channels.set(t.id, t)
                }
                return this._channels
            }
            has(e, {
                ignoreDirect: t = !1,
                ignoreRoles: i = !1,
                ignoreEveryone: n = !1
            } = {}) {
                if (!n && this.everyone) return !0;
                const r = s(10);
                if (!i && e instanceof r)
                    for (const t of this.roles.values())
                        if (e.roles.cache.has(t.id)) return !0;
                if (!t) {
                    const t = e.id || e;
                    return this.users.has(t) || this.channels.has(t) || this.roles.has(t)
                }
                return !1
            }
            toJSON() {
                return r.flatten(this, {
                    members: !0,
                    channels: !0
                })
            }
        }
        MessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g, MessageMentions.USERS_PATTERN = /<@!?(\d{17,19})>/g, MessageMentions.ROLES_PATTERN = /<@&(\d{17,19})>/g, MessageMentions.CHANNELS_PATTERN = /<#(\d{17,19})>/g, e.exports = MessageMentions
    }, function (e, t, s) {
        "use strict";
        const i = s(40),
            n = s(2),
            {
                Events: r
            } = s(0);
        class ReactionCollector extends i {
            constructor(e, t, s = {}) {
                super(e.client, t, s), this.message = e, this.users = new n, this.total = 0, this.empty = this.empty.bind(this), this._handleChannelDeletion = this._handleChannelDeletion.bind(this), this._handleGuildDeletion = this._handleGuildDeletion.bind(this), this._handleMessageDeletion = this._handleMessageDeletion.bind(this), 0 !== this.client.getMaxListeners() && this.client.setMaxListeners(this.client.getMaxListeners() + 1), this.client.on(r.MESSAGE_REACTION_ADD, this.handleCollect), this.client.on(r.MESSAGE_REACTION_REMOVE, this.handleDispose), this.client.on(r.MESSAGE_REACTION_REMOVE_ALL, this.empty), this.client.on(r.MESSAGE_DELETE, this._handleMessageDeletion), this.client.on(r.CHANNEL_DELETE, this._handleChannelDeletion), this.client.on(r.GUILD_DELETE, this._handleGuildDeletion), this.once("end", () => {
                    this.client.removeListener(r.MESSAGE_REACTION_ADD, this.handleCollect), this.client.removeListener(r.MESSAGE_REACTION_REMOVE, this.handleDispose), this.client.removeListener(r.MESSAGE_REACTION_REMOVE_ALL, this.empty), this.client.removeListener(r.MESSAGE_DELETE, this._handleMessageDeletion), this.client.removeListener(r.CHANNEL_DELETE, this._handleChannelDeletion), this.client.removeListener(r.GUILD_DELETE, this._handleGuildDeletion), 0 !== this.client.getMaxListeners() && this.client.setMaxListeners(this.client.getMaxListeners() - 1)
                }), this.on("collect", (e, t) => {
                    this.total++, this.users.set(t.id, t)
                }), this.on("remove", (e, t) => {
                    this.total--, this.collected.some(e => e.users.cache.has(t.id)) || this.users.delete(t.id)
                })
            }
            collect(e) {
                return e.message.id !== this.message.id ? null : ReactionCollector.key(e)
            }
            dispose(e, t) {
                return e.message.id !== this.message.id ? null : (this.collected.has(ReactionCollector.key(e)) && this.users.has(t.id) && this.emit("remove", e, t), e.count ? null : ReactionCollector.key(e))
            }
            empty() {
                this.total = 0, this.collected.clear(), this.users.clear(), this.checkEnd()
            }
            endReason() {
                return this.options.max && this.total >= this.options.max ? "limit" : this.options.maxEmojis && this.collected.size >= this.options.maxEmojis ? "emojiLimit" : this.options.maxUsers && this.users.size >= this.options.maxUsers ? "userLimit" : null
            }
            _handleMessageDeletion(e) {
                e.id === this.message.id && this.stop("messageDelete")
            }
            _handleChannelDeletion(e) {
                e.id === this.message.channel.id && this.stop("channelDelete")
            }
            _handleGuildDeletion(e) {
                this.message.guild && e.id === this.message.guild.id && this.stop("guildDelete")
            }
            static key(e) {
                return e.emoji.id || e.emoji.name
            }
        }
        e.exports = ReactionCollector
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            {
                Error: n
            } = s(3),
            r = s(2);
        e.exports = class ReactionUserManager extends i {
            constructor(e, t, s) {
                super(e, t, {
                    name: "User"
                }), this.reaction = s
            }
            async fetch({
                limit: e = 100,
                after: t,
                before: s
            } = {}) {
                const i = this.reaction.message,
                    n = await this.client.api.channels[i.channel.id].messages[i.id].reactions[this.reaction.emoji.identifier].get({
                        query: {
                            limit: e,
                            before: s,
                            after: t
                        }
                    }),
                    o = new r;
                for (const e of n) {
                    const t = this.client.users.add(e);
                    this.cache.set(t.id, t), o.set(t.id, t)
                }
                return o
            }
            remove(e = this.reaction.message.client.user) {
                const t = this.reaction.message,
                    s = t.client.users.resolveID(e);
                return s ? t.client.api.channels[t.channel.id].messages[t.id].reactions[this.reaction.emoji.identifier][s === t.client.user.id ? "@me" : s].delete().then(() => this.reaction) : Promise.reject(new n("REACTION_RESOLVE_USER"))
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(15),
            {
                Error: n
            } = s(3),
            r = s(2),
            {
                browser: o
            } = s(0),
            a = s(8);
        e.exports = class VoiceChannel extends i {
            _patch(e) {
                super._patch(e), this.bitrate = e.bitrate, this.userLimit = e.user_limit
            }
            get members() {
                const e = new r;
                for (const t of this.guild.voiceStates.cache.values()) t.channelID === this.id && t.member && e.set(t.id, t.member);
                return e
            }
            get full() {
                return this.userLimit > 0 && this.members.size >= this.userLimit
            }
            get deletable() {
                return super.deletable && this.permissionsFor(this.client.user).has(a.FLAGS.CONNECT, !1)
            }
            get editable() {
                return this.manageable && this.permissionsFor(this.client.user).has(a.FLAGS.CONNECT, !1)
            }
            get joinable() {
                return !o && (!!this.viewable && (!!this.permissionsFor(this.client.user).has(a.FLAGS.CONNECT, !1) && !(this.full && !this.permissionsFor(this.client.user).has(a.FLAGS.MOVE_MEMBERS, !1))))
            }
            get speakable() {
                return this.permissionsFor(this.client.user).has(a.FLAGS.SPEAK, !1)
            }
            setBitrate(e, t) {
                return this.edit({
                    bitrate: e
                }, t)
            }
            setUserLimit(e, t) {
                return this.edit({
                    userLimit: e
                }, t)
            }
            join() {
                return o ? Promise.reject(new n("VOICE_NO_BROWSER")) : this.client.voice.joinChannel(this)
            }
            leave() {
                if (o) return;
                const e = this.client.voice.connections.get(this.guild.id);
                e && e.channel.id === this.id && e.disconnect()
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(15);
        e.exports = class CategoryChannel extends i {
            get children() {
                return this.guild.channels.cache.filter(e => e.parentID === this.id)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(34);
        e.exports = class NewsChannel extends i {
            _patch(e) {
                super._patch(e), this.rateLimitPerUser = void 0
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(15);
        e.exports = class StoreChannel extends i {
            _patch(e) {
                super._patch(e), this.nsfw = e.nsfw
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(45),
            n = s(11),
            r = s(2),
            {
                PartialTypes: o
            } = s(0),
            a = s(7),
            c = s(4),
            l = {
                ALL: "ALL",
                GUILD: "GUILD",
                CHANNEL: "CHANNEL",
                USER: "USER",
                ROLE: "ROLE",
                INVITE: "INVITE",
                WEBHOOK: "WEBHOOK",
                EMOJI: "EMOJI",
                MESSAGE: "MESSAGE",
                INTEGRATION: "INTEGRATION",
                UNKNOWN: "UNKNOWN"
            },
            h = {
                ALL: null,
                GUILD_UPDATE: 1,
                CHANNEL_CREATE: 10,
                CHANNEL_UPDATE: 11,
                CHANNEL_DELETE: 12,
                CHANNEL_OVERWRITE_CREATE: 13,
                CHANNEL_OVERWRITE_UPDATE: 14,
                CHANNEL_OVERWRITE_DELETE: 15,
                MEMBER_KICK: 20,
                MEMBER_PRUNE: 21,
                MEMBER_BAN_ADD: 22,
                MEMBER_BAN_REMOVE: 23,
                MEMBER_UPDATE: 24,
                MEMBER_ROLE_UPDATE: 25,
                MEMBER_MOVE: 26,
                MEMBER_DISCONNECT: 27,
                BOT_ADD: 28,
                ROLE_CREATE: 30,
                ROLE_UPDATE: 31,
                ROLE_DELETE: 32,
                INVITE_CREATE: 40,
                INVITE_UPDATE: 41,
                INVITE_DELETE: 42,
                WEBHOOK_CREATE: 50,
                WEBHOOK_UPDATE: 51,
                WEBHOOK_DELETE: 52,
                EMOJI_CREATE: 60,
                EMOJI_UPDATE: 61,
                EMOJI_DELETE: 62,
                MESSAGE_DELETE: 72,
                MESSAGE_BULK_DELETE: 73,
                MESSAGE_PIN: 74,
                MESSAGE_UNPIN: 75,
                INTEGRATION_CREATE: 80,
                INTEGRATION_UPDATE: 81,
                INTEGRATION_DELETE: 82
            };
        class GuildAuditLogs {
            constructor(e, t) {
                if (t.users)
                    for (const s of t.users) e.client.users.add(s);
                if (this.webhooks = new r, t.webhooks)
                    for (const s of t.webhooks) this.webhooks.set(s.id, new n(e.client, s));
                if (this.integrations = new r, t.integrations)
                    for (const s of t.integrations) this.integrations.set(s.id, new i(e.client, s, e));
                this.entries = new r;
                for (const s of t.audit_log_entries) {
                    const t = new GuildAuditLogsEntry(this, e, s);
                    this.entries.set(t.id, t)
                }
            }
            static build(...e) {
                const t = new GuildAuditLogs(...e);
                return Promise.all(t.entries.map(e => e.target)).then(() => t)
            }
            static targetType(e) {
                return e < 10 ? l.GUILD : e < 20 ? l.CHANNEL : e < 30 ? l.USER : e < 40 ? l.ROLE : e < 50 ? l.INVITE : e < 60 ? l.WEBHOOK : e < 70 ? l.EMOJI : e < 80 ? l.MESSAGE : e < 90 ? l.INTEGRATION : l.UNKNOWN
            }
            static actionType(e) {
                return [h.CHANNEL_CREATE, h.CHANNEL_OVERWRITE_CREATE, h.MEMBER_BAN_REMOVE, h.BOT_ADD, h.ROLE_CREATE, h.INVITE_CREATE, h.WEBHOOK_CREATE, h.EMOJI_CREATE, h.MESSAGE_PIN, h.INTEGRATION_CREATE].includes(e) ? "CREATE" : [h.CHANNEL_DELETE, h.CHANNEL_OVERWRITE_DELETE, h.MEMBER_KICK, h.MEMBER_PRUNE, h.MEMBER_BAN_ADD, h.MEMBER_DISCONNECT, h.ROLE_DELETE, h.INVITE_DELETE, h.WEBHOOK_DELETE, h.EMOJI_DELETE, h.MESSAGE_DELETE, h.MESSAGE_BULK_DELETE, h.MESSAGE_UNPIN, h.INTEGRATION_DELETE].includes(e) ? "DELETE" : [h.GUILD_UPDATE, h.CHANNEL_UPDATE, h.CHANNEL_OVERWRITE_UPDATE, h.MEMBER_UPDATE, h.MEMBER_ROLE_UPDATE, h.MEMBER_MOVE, h.ROLE_UPDATE, h.INVITE_UPDATE, h.WEBHOOK_UPDATE, h.EMOJI_UPDATE, h.INTEGRATION_UPDATE].includes(e) ? "UPDATE" : "ALL"
            }
            toJSON() {
                return c.flatten(this)
            }
        }
        class GuildAuditLogsEntry {
            constructor(e, t, s) {
                const r = GuildAuditLogs.targetType(s.action_type);
                switch (this.targetType = r, this.actionType = GuildAuditLogs.actionType(s.action_type), this.action = Object.keys(h).find(e => h[e] === s.action_type), this.reason = s.reason || null, this.executor = t.client.options.partials.includes(o.USER) ? t.client.users.add({
                    id: s.user_id
                }) : t.client.users.cache.get(s.user_id), this.changes = s.changes ? s.changes.map(e => ({
                    key: e.key,
                    old: e.old_value,
                    new: e.new_value
                })) : null, this.id = s.id, this.extra = null, s.action_type) {
                    case h.MEMBER_PRUNE:
                        this.extra = {
                            removed: Number(s.options.members_removed),
                            days: Number(s.options.delete_member_days)
                        };
                        break;
                    case h.MEMBER_MOVE:
                    case h.MESSAGE_DELETE:
                    case h.MESSAGE_BULK_DELETE:
                        this.extra = {
                            channel: t.channels.cache.get(s.options.channel_id) || {
                                id: s.options.channel_id
                            },
                            count: Number(s.options.count)
                        };
                        break;
                    case h.MESSAGE_PIN:
                    case h.MESSAGE_UNPIN:
                        this.extra = {
                            channel: t.client.channels.cache.get(s.options.channel_id) || {
                                id: s.options.channel_id
                            },
                            messageID: s.options.message_id
                        };
                        break;
                    case h.MEMBER_DISCONNECT:
                        this.extra = {
                            count: Number(s.options.count)
                        };
                        break;
                    case h.CHANNEL_OVERWRITE_CREATE:
                    case h.CHANNEL_OVERWRITE_UPDATE:
                    case h.CHANNEL_OVERWRITE_DELETE:
                        switch (s.options.type) {
                            case "member":
                                this.extra = t.members.cache.get(s.options.id) || {
                                    id: s.options.id,
                                    type: "member"
                                };
                                break;
                            case "role":
                                this.extra = t.roles.cache.get(s.options.id) || {
                                    id: s.options.id,
                                    name: s.options.role_name,
                                    type: "role"
                                }
                        }
                }
                this.target = null, r === l.UNKNOWN ? (this.target = this.changes.reduce((e, t) => (e[t.key] = t.new || t.old, e), {}), this.target.id = s.target_id) : r === l.USER && s.target_id ? this.target = t.client.options.partials.includes(o.USER) ? t.client.users.add({
                    id: s.target_id
                }) : t.client.users.cache.get(s.target_id) : r === l.GUILD ? this.target = t.client.guilds.cache.get(s.target_id) : r === l.WEBHOOK ? this.target = e.webhooks.get(s.target_id) || new n(t.client, this.changes.reduce((e, t) => (e[t.key] = t.new || t.old, e), {
                    id: s.target_id,
                    guild_id: t.id
                })) : r === l.INVITE ? this.target = t.members.fetch(t.client.user.id).then(e => {
                    if (e.permissions.has("MANAGE_GUILD")) {
                        const e = this.changes.find(e => "code" === e.key);
                        return t.fetchInvites().then(t => {
                            this.target = t.find(t => t.code === (e.new || e.old))
                        })
                    }
                    return this.target = this.changes.reduce((e, t) => (e[t.key] = t.new || t.old, e), {}), this.target
                }) : r === l.MESSAGE ? this.target = s.action_type === h.MESSAGE_BULK_DELETE ? t.channels.cache.get(s.target_id) || {
                    id: s.target_id
                } : t.client.users.cache.get(s.target_id) : r === l.INTEGRATION ? this.target = e.integrations.get(s.target_id) || new i(t.client, this.changes.reduce((e, t) => (e[t.key] = t.new || t.old, e), {
                    id: s.target_id
                }), t) : s.target_id && (this.target = t[`${r.toLowerCase()}s`].cache.get(s.target_id) || {
                    id: s.target_id
                })
            }
            get createdTimestamp() {
                return a.deconstruct(this.id).timestamp
            }
            get createdAt() {
                return new Date(this.createdTimestamp)
            }
            toJSON() {
                return c.flatten(this, {
                    createdTimestamp: !0
                })
            }
        }
        GuildAuditLogs.Actions = h, GuildAuditLogs.Targets = l, GuildAuditLogs.Entry = GuildAuditLogsEntry, e.exports = GuildAuditLogs
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            n = s(15),
            r = s(35),
            {
                ChannelTypes: o
            } = s(0);
        e.exports = class GuildChannelManager extends i {
            constructor(e, t) {
                super(e.client, t, n), this.guild = e
            }
            add(e) {
                const t = this.cache.get(e.id);
                return t || (this.cache.set(e.id, e), e)
            }
            async create(e, t = {}) {
                let {
                    type: s,
                    topic: i,
                    nsfw: n,
                    bitrate: a,
                    userLimit: c,
                    parent: l,
                    permissionOverwrites: h,
                    position: u,
                    rateLimitPerUser: d,
                    reason: p
                } = t;
                l && (l = this.client.channels.resolveID(l)), h && (h = h.map(e => r.resolve(e, this.guild)));
                const m = await this.client.api.guilds(this.guild.id).channels.post({
                    data: {
                        name: e,
                        topic: i,
                        type: s ? o[s.toUpperCase()] : o.TEXT,
                        nsfw: n,
                        bitrate: a,
                        user_limit: c,
                        parent_id: l,
                        position: u,
                        permission_overwrites: h,
                        rate_limit_per_user: d
                    },
                    reason: p
                });
                return this.client.actions.ChannelCreate.handle(m).channel
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            {
                Error: n,
                TypeError: r
            } = s(3),
            o = s(10),
            a = s(2),
            {
                Events: c,
                OPCodes: l
            } = s(0);
        e.exports = class GuildMemberManager extends i {
            constructor(e, t) {
                super(e.client, t, o), this.guild = e
            }
            add(e, t = !0) {
                return super.add(e, t, {
                    id: e.user.id,
                    extras: [this.guild]
                })
            }
            resolve(e) {
                const t = super.resolve(e);
                if (t) return t;
                const s = this.client.users.resolveID(e);
                return s ? super.resolve(s) : null
            }
            resolveID(e) {
                const t = super.resolveID(e);
                if (t) return t;
                const s = this.client.users.resolveID(e);
                return this.cache.has(s) ? s : null
            }
            fetch(e) {
                if (!e) return this._fetchMany();
                const t = this.client.users.resolveID(e);
                if (t) return this._fetchSingle({
                    user: t,
                    cache: !0
                });
                if (e.user) {
                    if (Array.isArray(e.user)) return e.user = e.user.map(e => this.client.users.resolveID(e)), this._fetchMany(e);
                    if (e.user = this.client.users.resolveID(e.user), !e.limit && !e.withPresences) return this._fetchSingle(e)
                }
                return this._fetchMany(e)
            }
            prune({
                days: e = 7,
                dry: t = !1,
                count: s = !0,
                reason: i
            } = {}) {
                if ("number" != typeof e) throw new r("PRUNE_DAYS_TYPE");
                return this.client.api.guilds(this.guild.id).prune[t ? "get" : "post"]({
                    query: {
                        days: e,
                        compute_prune_count: s
                    },
                    reason: i
                }).then(e => e.pruned)
            }
            ban(e, t = {
                days: 0
            }) {
                t.days && (t["delete-message-days"] = t.days);
                const s = this.client.users.resolveID(e);
                return s ? this.client.api.guilds(this.guild.id).bans[s].put({
                    query: t
                }).then(() => {
                    if (e instanceof o) return e;
                    const t = this.client.users.resolve(s);
                    if (t) {
                        return this.resolve(t) || t
                    }
                    return s
                }) : Promise.reject(new n("BAN_RESOLVE_ID", !0))
            }
            unban(e, t) {
                const s = this.client.users.resolveID(e);
                return s ? this.client.api.guilds(this.guild.id).bans[s].delete({
                    reason: t
                }).then(() => this.client.users.resolve(e)) : Promise.reject(new n("BAN_RESOLVE_ID"))
            }
            _fetchSingle({
                user: e,
                cache: t
            }) {
                const s = this.cache.get(e);
                return s && !s.partial ? Promise.resolve(s) : this.client.api.guilds(this.guild.id).members(e).get().then(e => this.add(e, t))
            }
            _fetchMany({
                limit: e = 0,
                withPresences: t = !1,
                user: s,
                query: i
            } = {}) {
                return new Promise((r, o) => {
                    if (!(this.guild.memberCount !== this.cache.size || i || e || t || s)) return void r(this.cache);
                    i || s || (i = ""), this.guild.shard.send({
                        op: l.REQUEST_GUILD_MEMBERS,
                        d: {
                            guild_id: this.guild.id,
                            presences: t,
                            user_ids: s,
                            query: i,
                            limit: e
                        }
                    });
                    const h = new a,
                        u = i || e || t || s,
                        d = (t, i) => {
                            if (i.id === this.guild.id) {
                                p.refresh();
                                for (const e of t.values()) u && h.set(e.id, e);
                                if (this.guild.memberCount <= this.cache.size || u && t.size < 1e3 || e && h.size >= e) {
                                    this.guild.client.removeListener(c.GUILD_MEMBERS_CHUNK, d);
                                    let e = u ? h : this.cache;
                                    s && !Array.isArray(s) && e.size && (e = e.first()), r(e)
                                }
                            }
                        },
                        p = this.guild.client.setTimeout(() => {
                            this.guild.client.removeListener(c.GUILD_MEMBERS_CHUNK, d), o(new n("GUILD_MEMBERS_TIMEOUT"))
                        }, 12e4);
                    this.guild.client.on(c.GUILD_MEMBERS_CHUNK, d)
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            {
                Presence: n
            } = s(12);
        e.exports = class PresenceManager extends i {
            constructor(e, t) {
                super(e, t, n)
            }
            add(e, t) {
                const s = this.cache.get(e.user.id);
                return s ? s.patch(e) : super.add(e, t, {
                    id: e.user.id
                })
            }
            resolve(e) {
                const t = super.resolve(e);
                if (t) return t;
                const s = this.client.users.resolveID(e);
                return super.resolve(s) || null
            }
            resolveID(e) {
                const t = super.resolveID(e);
                if (t) return t;
                const s = this.client.users.resolveID(e);
                return this.cache.has(s) ? s : null
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            n = s(17),
            r = s(8),
            {
                resolveColor: o
            } = s(4);
        e.exports = class RoleManager extends i {
            constructor(e, t) {
                super(e.client, t, n), this.guild = e
            }
            add(e, t) {
                return super.add(e, t, {
                    extras: [this.guild]
                })
            }
            async fetch(e, t = !0) {
                if (e) {
                    const t = this.cache.get(e);
                    if (t) return t
                }
                const s = await this.client.api.guilds(this.guild.id).roles.get();
                for (const e of s) this.add(e, t);
                return e ? this.cache.get(e) || null : this
            }
            create({
                data: e = {},
                reason: t
            } = {}) {
                return e.color && (e.color = o(e.color)), e.permissions && (e.permissions = r.resolve(e.permissions)), this.guild.client.api.guilds(this.guild.id).roles.post({
                    data: e,
                    reason: t
                }).then(s => {
                    const {
                        role: i
                    } = this.client.actions.GuildRoleCreate.handle({
                        guild_id: this.guild.id,
                        role: s
                    });
                    return e.position ? i.setPosition(e.position, t) : i
                })
            }
            get everyone() {
                return this.cache.get(this.guild.id) || null
            }
            get highest() {
                return this.cache.reduce((e, t) => t.comparePositionTo(e) > 0 ? t : e, this.cache.first())
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(14);
        class SystemChannelFlags extends i {}
        SystemChannelFlags.FLAGS = {
            WELCOME_MESSAGE_DISABLED: 1,
            BOOST_MESSAGE_DISABLED: 2
        }, e.exports = SystemChannelFlags
    }, function (e, t, s) {
        "use strict";
        const {
            Presence: i
        } = s(12), {
            TypeError: n
        } = s(3), r = s(2), {
            ActivityTypes: o,
            OPCodes: a
        } = s(0);
        e.exports = class ClientPresence extends i {
            constructor(e, t = {}) {
                super(e, Object.assign(t, {
                    status: "online",
                    user: {
                        id: null
                    }
                }))
            }
            async set(e) {
                const t = await this._parse(e);
                if (this.patch(t), void 0 === e.shardID) this.client.ws.broadcast({
                    op: a.STATUS_UPDATE,
                    d: t
                });
                else if (Array.isArray(e.shardID))
                    for (const s of e.shardID) this.client.ws.shards.get(s).send({
                        op: a.STATUS_UPDATE,
                        d: t
                    });
                else this.client.ws.shards.get(e.shardID).send({
                    op: a.STATUS_UPDATE,
                    d: t
                });
                return this
            }
            async _parse({
                status: e,
                since: t,
                afk: s,
                activity: i
            }) {
                const a = i && (i.application ? i.application.id || i.application : null);
                let c = new r;
                if (i) {
                    if ("string" != typeof i.name) throw new n("INVALID_TYPE", "name", "string");
                    if (i.type || (i.type = 0), i.assets && a) try {
                        const e = await this.client.api.oauth2.applications(a).assets.get();
                        for (const t of e) c.set(t.name, t.id)
                    } catch {}
                }
                const l = {
                    afk: null != s && s,
                    since: null != t ? t : null,
                    status: e || this.status,
                    game: i ? {
                        type: i.type,
                        name: i.name,
                        url: i.url,
                        details: i.details || void 0,
                        state: i.state || void 0,
                        assets: i.assets ? {
                            large_text: i.assets.largeText || void 0,
                            small_text: i.assets.smallText || void 0,
                            large_image: c.get(i.assets.largeImage) || i.assets.largeImage,
                            small_image: c.get(i.assets.smallImage) || i.assets.smallImage
                        } : void 0,
                        timestamps: i.timestamps || void 0,
                        party: i.party || void 0,
                        application_id: a || void 0,
                        secrets: i.secrets || void 0,
                        instance: i.instance || void 0
                    } : null
                };
                return (e || s || t) && !i && (l.game = this.activities[0] || null), l.game && (l.game.type = "number" == typeof l.game.type ? l.game.type : o.indexOf(l.game.type)), l
            }
        }
    }, function (e, t, s) {
        "use strict";
        const {
            browser: i
        } = s(0);
        let n, r;
        try {
            n = s(134), n.pack || (n = null)
        } catch {}
        i ? (r = window.TextDecoder, t.WebSocket = window.WebSocket) : (r = s(135).TextDecoder, t.WebSocket = s(138));
        const o = new r;
        t.encoding = n ? "etf" : "json", t.pack = n ? n.pack : JSON.stringify, t.unpack = (e, s) => "json" === t.encoding || "json" === s ? ("string" != typeof e && (e = o.decode(e)), JSON.parse(e)) : (Buffer.isBuffer(e) || (e = Buffer.from(new Uint8Array(e))), n.unpack(e)), t.create = (e, s = {}, ...n) => {
            const [r, o] = e.split("?");
            s.encoding = t.encoding, s = new URLSearchParams(s), o && new URLSearchParams(o).forEach((e, t) => s.set(t, e));
            const a = new t.WebSocket(`${r}?${s}`, ...n);
            return i && (a.binaryType = "arraybuffer"), a
        };
        for (const e of ["CONNECTING", "OPEN", "CLOSING", "CLOSED"]) t[e] = t.WebSocket[e]
    }, function (e, t, s) {
        "use strict";
        const {
            WSEvents: i
        } = s(0), n = {};
        for (const e of Object.keys(i)) try {
            n[e] = s(140)(`./${e}.js`)
        } catch {}
        e.exports = n
    }, function (e, t, s) {
        "use strict";
        const i = s(9),
            n = s(18);
        class ClientUser extends(n.get("User")) {
            constructor(e, t) {
                super(e, t), this._typing = new Map
            }
            _patch(e) {
                super._patch(e), "verified" in e && (this.verified = e.verified), "mfa_enabled" in e ? this.mfaEnabled = "boolean" == typeof e.mfa_enabled ? e.mfa_enabled : null : void 0 === this.mfaEnabled && (this.mfaEnabled = null), e.token && (this.client.token = e.token)
            }
            get presence() {
                return this.client.presence
            }
            edit(e) {
                return this.client.api.users("@me").patch({
                    data: e
                }).then(e => {
                    this.client.token = e.token;
                    const {
                        updated: t
                    } = this.client.actions.UserUpdate.handle(e);
                    return t || this
                })
            }
            setUsername(e) {
                return this.edit({
                    username: e
                })
            }
            async setAvatar(e) {
                return this.edit({
                    avatar: await i.resolveImage(e)
                })
            }
            setPresence(e) {
                return this.client.presence.set(e)
            }
            setStatus(e, t) {
                return this.setPresence({
                    status: e,
                    shardID: t
                })
            }
            setActivity(e, t = {}) {
                if (!e) return this.setPresence({
                    activity: null,
                    shardID: t.shardID
                });
                const s = Object.assign({}, t, "object" == typeof e ? e : {
                    name: e
                });
                return this.setPresence({
                    activity: s,
                    shardID: s.shardID
                })
            }
            setAFK(e) {
                return this.setPresence({
                    afk: e
                })
            }
        }
        e.exports = ClientUser
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            n = s(13),
            {
                Events: r
            } = s(0);
        e.exports = class ChannelManager extends i {
            constructor(e, t) {
                super(e, t, n)
            }
            add(e, t, s = !0) {
                const i = this.cache.get(e.id);
                if (i) return i._patch && s && i._patch(e), t && t.channels.add(i), i;
                const o = n.create(this.client, e, t);
                return o ? (s && this.cache.set(o.id, o), o) : (this.client.emit(r.DEBUG, `Failed to find guild, or unknown type for channel ${e.id} ${e.type}`), null)
            }
            remove(e) {
                const t = this.cache.get(e);
                t.guild && t.guild.channels.cache.delete(e), this.cache.delete(e)
            }
            async fetch(e, t = !0) {
                const s = this.cache.get(e);
                if (s && !s.partial) return s;
                const i = await this.client.api.channels(e).get();
                return this.add(i, null, t)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            n = s(44),
            r = s(15),
            o = s(19),
            a = s(10),
            c = s(16),
            l = s(17),
            {
                Events: h,
                VerificationLevels: u,
                DefaultMessageNotifications: d,
                ExplicitContentFilterLevels: p
            } = s(0),
            m = s(9),
            g = s(8),
            {
                resolveColor: E
            } = s(4);
        e.exports = class GuildManager extends i {
            constructor(e, t) {
                super(e, t, n)
            }
            resolve(e) {
                return e instanceof r || e instanceof a || e instanceof o || e instanceof l || e instanceof c && e.guild ? super.resolve(e.guild) : super.resolve(e)
            }
            resolveID(e) {
                return e instanceof r || e instanceof a || e instanceof o || e instanceof l || e instanceof c && e.guild ? super.resolveID(e.guild.id) : super.resolveID(e)
            }
            async create(e, {
                channels: t = [],
                defaultMessageNotifications: s,
                explicitContentFilter: i,
                icon: n = null,
                region: r,
                roles: o = [],
                verificationLevel: a
            } = {}) {
                n = await m.resolveImage(n), void 0 !== a && "number" != typeof a && (a = u.indexOf(a)), void 0 !== s && "number" != typeof s && (s = d.indexOf(s)), void 0 !== i && "number" != typeof i && (i = p.indexOf(i));
                for (const e of t)
                    if (e.parent_id = e.parentID, delete e.parentID, e.permissionOverwrites) {
                        for (const t of e.permissionOverwrites) t.allow && (t.allow = g.resolve(t.allow)), t.deny && (t.deny = g.resolve(t.deny));
                        e.permission_overwrites = e.permissionOverwrites, delete e.permissionOverwrites
                    } for (const e of o) e.color && (e.color = E(e.color)), e.permissions && (e.permissions = g.resolve(e.permissions));
                return new Promise((c, l) => this.client.api.guilds.post({
                    data: {
                        name: e,
                        region: r,
                        icon: n,
                        verification_level: a,
                        default_message_notifications: s,
                        explicit_content_filter: i,
                        channels: t,
                        roles: o
                    }
                }).then(e => {
                    if (this.client.guilds.cache.has(e.id)) return c(this.client.guilds.cache.get(e.id));
                    const t = i => {
                        i.id === e.id && (this.client.removeListener(h.GUILD_CREATE, t), this.client.clearTimeout(s), c(i))
                    };
                    this.client.on(h.GUILD_CREATE, t);
                    const s = this.client.setTimeout(() => {
                        this.client.removeListener(h.GUILD_CREATE, t), c(this.client.guilds.add(e))
                    }, 1e4)
                }, l))
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            n = s(10),
            r = s(22),
            o = s(20);
        e.exports = class UserManager extends i {
            constructor(e, t) {
                super(e, t, o)
            }
            resolve(e) {
                return e instanceof n ? e.user : e instanceof r ? e.author : super.resolve(e)
            }
            resolveID(e) {
                return e instanceof n ? e.user.id : e instanceof r ? e.author.id : super.resolveID(e)
            }
            async fetch(e, t = !0) {
                const s = this.cache.get(e);
                if (s && !s.partial) return s;
                const i = await this.client.api.users(e).get();
                return this.add(i, t)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(14);
        class Intents extends i {}
        Intents.FLAGS = {
            GUILDS: 1,
            GUILD_MEMBERS: 2,
            GUILD_BANS: 4,
            GUILD_EMOJIS: 8,
            GUILD_INTEGRATIONS: 16,
            GUILD_WEBHOOKS: 32,
            GUILD_INVITES: 64,
            GUILD_VOICE_STATES: 128,
            GUILD_PRESENCES: 256,
            GUILD_MESSAGES: 512,
            GUILD_MESSAGE_REACTIONS: 1024,
            GUILD_MESSAGE_TYPING: 2048,
            DIRECT_MESSAGES: 4096,
            DIRECT_MESSAGE_REACTIONS: 8192,
            DIRECT_MESSAGE_TYPING: 16384
        }, Intents.PRIVILEGED = Intents.FLAGS.GUILD_MEMBERS | Intents.FLAGS.GUILD_PRESENCES, Intents.ALL = Object.values(Intents.FLAGS).reduce((e, t) => e | t, 0), Intents.NON_PRIVILEGED = Intents.ALL & ~Intents.PRIVILEGED, e.exports = Intents
    }, function (e, t, s) {
        "use strict";
        const i = s(4);
        e.exports = {
            BaseClient: s(31),
            Client: s(93),
            Shard: s(179),
            ShardClientUtil: s(180),
            ShardingManager: s(181),
            WebhookClient: s(39),
            ActivityFlags: s(57),
            BitField: s(14),
            Collection: s(2),
            Constants: s(0),
            DataResolver: s(9),
            BaseManager: s(6),
            DiscordAPIError: s(54),
            HTTPError: s(55),
            MessageFlags: s(38),
            Intents: s(82),
            Permissions: s(8),
            Speaking: s(182),
            Snowflake: s(7),
            SnowflakeUtil: s(7),
            Structures: s(18),
            SystemChannelFlags: s(74),
            Util: i,
            version: s(49).version,
            ChannelManager: s(79),
            GuildChannelManager: s(70),
            GuildEmojiManager: s(48),
            GuildEmojiRoleManager: s(56),
            GuildMemberManager: s(71),
            GuildMemberRoleManager: s(59),
            GuildManager: s(80),
            ReactionUserManager: s(64),
            MessageManager: s(28),
            PresenceManager: s(72),
            RoleManager: s(73),
            UserManager: s(81),
            discordSort: i.discordSort,
            escapeMarkdown: i.escapeMarkdown,
            fetchRecommendedShards: i.fetchRecommendedShards,
            resolveColor: i.resolveColor,
            resolveString: i.resolveString,
            splitMessage: i.splitMessage,
            Base: s(5),
            Activity: s(12).Activity,
            APIMessage: s(26),
            BaseGuildEmoji: s(33),
            CategoryChannel: s(66),
            Channel: s(13),
            ClientApplication: s(41),
            get ClientUser() {
                return s(78)
            },
            Collector: s(40),
            DMChannel: s(32),
            Emoji: s(25),
            Guild: s(44),
            GuildAuditLogs: s(69),
            GuildChannel: s(15),
            GuildEmoji: s(19),
            GuildMember: s(10),
            GuildPreview: s(46),
            Integration: s(45),
            Invite: s(16),
            Message: s(22),
            MessageAttachment: s(36),
            MessageCollector: s(58),
            MessageEmbed: s(37),
            MessageMentions: s(62),
            MessageReaction: s(42),
            NewsChannel: s(67),
            PermissionOverwrites: s(35),
            Presence: s(12).Presence,
            ClientPresence: s(75),
            ReactionCollector: s(63),
            ReactionEmoji: s(43),
            RichPresenceAssets: s(12).RichPresenceAssets,
            Role: s(17),
            StoreChannel: s(68),
            Team: s(60),
            TeamMember: s(61),
            TextChannel: s(34),
            User: s(20),
            VoiceChannel: s(65),
            VoiceRegion: s(47),
            VoiceState: s(21),
            Webhook: s(11),
            WebSocket: s(76)
        }
    }, function (e, t, s) {
        "use strict";
        const {
            register: i
        } = s(50), n = {
            CLIENT_INVALID_OPTION: (e, t) => `The ${e} option must be ${t}`,
            CLIENT_INVALID_PROVIDED_SHARDS: "None of the provided shards were valid.",
            TOKEN_INVALID: "An invalid token was provided.",
            TOKEN_MISSING: "Request to use token, but token was unavailable to the client.",
            WS_CLOSE_REQUESTED: "WebSocket closed due to user request.",
            WS_CONNECTION_EXISTS: "There is already an existing WebSocket connection.",
            WS_NOT_OPEN: (e = "data") => `Websocket not open to send ${e}`,
            BITFIELD_INVALID: "Invalid bitfield flag or number.",
            SHARDING_INVALID: "Invalid shard settings were provided.",
            SHARDING_REQUIRED: "This session would have handled too many guilds - Sharding is required.",
            INVALID_INTENTS: "Invalid intent provided for WebSocket intents.",
            DISALLOWED_INTENTS: "Privileged intent provided is not enabled or whitelisted.",
            SHARDING_NO_SHARDS: "No shards have been spawned.",
            SHARDING_IN_PROCESS: "Shards are still being spawned.",
            SHARDING_ALREADY_SPAWNED: e => `Already spawned ${e} shards.`,
            SHARDING_PROCESS_EXISTS: e => `Shard ${e} already has an active process.`,
            SHARDING_READY_TIMEOUT: e => `Shard ${e}'s Client took too long to become ready.`,
            SHARDING_READY_DISCONNECTED: e => `Shard ${e}'s Client disconnected before becoming ready.`,
            SHARDING_READY_DIED: e => `Shard ${e}'s process exited before its Client became ready.`,
            COLOR_RANGE: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
            COLOR_CONVERT: "Unable to convert color to a number.",
            EMBED_FIELD_NAME: "MessageEmbed field names may not be empty.",
            EMBED_FIELD_VALUE: "MessageEmbed field values may not be empty.",
            FILE_NOT_FOUND: e => `File could not be found: ${e}`,
            USER_NO_DMCHANNEL: "No DM Channel exists!",
            VOICE_INVALID_HEARTBEAT: "Tried to set voice heartbeat but no valid interval was specified.",
            VOICE_USER_MISSING: "Couldn't resolve the user to create stream.",
            VOICE_JOIN_CHANNEL: (e = !1) => `You do not have permission to join this voice channel${e?"; it is full.":"."}`,
            VOICE_CONNECTION_TIMEOUT: "Connection not established within 15 seconds.",
            VOICE_TOKEN_ABSENT: "Token not provided from voice server packet.",
            VOICE_SESSION_ABSENT: "Session ID not supplied.",
            VOICE_INVALID_ENDPOINT: "Invalid endpoint received.",
            VOICE_NO_BROWSER: "Voice connections are not available in browsers.",
            VOICE_CONNECTION_ATTEMPTS_EXCEEDED: e => `Too many connection attempts (${e}).`,
            VOICE_JOIN_SOCKET_CLOSED: "Tried to send join packet, but the WebSocket is not open.",
            VOICE_PLAY_INTERFACE_NO_BROADCAST: "A broadcast cannot be played in this context.",
            VOICE_PLAY_INTERFACE_BAD_TYPE: "Unknown stream type",
            VOICE_PRISM_DEMUXERS_NEED_STREAM: "To play a webm/ogg stream, you need to pass a ReadableStream.",
            VOICE_STATE_UNCACHED_MEMBER: "The member of this voice state is uncached.",
            VOICE_STATE_NOT_OWN: "You cannot self-deafen/mute on VoiceStates that do not belong to the ClientUser.",
            VOICE_STATE_INVALID_TYPE: e => `${e} must be a boolean.`,
            UDP_SEND_FAIL: "Tried to send a UDP packet, but there is no socket available.",
            UDP_ADDRESS_MALFORMED: "Malformed UDP address or port.",
            UDP_CONNECTION_EXISTS: "There is already an existing UDP connection.",
            REQ_RESOURCE_TYPE: "The resource must be a string, Buffer or a valid file stream.",
            IMAGE_FORMAT: e => `Invalid image format: ${e}`,
            IMAGE_SIZE: e => `Invalid image size: ${e}`,
            MESSAGE_BULK_DELETE_TYPE: "The messages must be an Array, Collection, or number.",
            MESSAGE_NONCE_TYPE: "Message nonce must fit in an unsigned 64-bit integer.",
            TYPING_COUNT: "Count must be at least 1",
            SPLIT_MAX_LEN: "Chunk exceeds the max length and contains no split characters.",
            BAN_RESOLVE_ID: (e = !1) => `Couldn't resolve the user ID to ${e?"ban":"unban"}.`,
            FETCH_BAN_RESOLVE_ID: "Couldn't resolve the user ID to fetch the ban.",
            PRUNE_DAYS_TYPE: "Days must be a number",
            GUILD_CHANNEL_RESOLVE: "Could not resolve channel to a guild channel.",
            GUILD_VOICE_CHANNEL_RESOLVE: "Could not resolve channel to a guild voice channel.",
            GUILD_CHANNEL_ORPHAN: "Could not find a parent to this guild channel.",
            GUILD_OWNED: "Guild is owned by the client.",
            GUILD_MEMBERS_TIMEOUT: "Members didn't arrive in time.",
            GUILD_UNCACHED_ME: "The client user as a member of this guild is uncached.",
            INVALID_TYPE: (e, t, s = !1) => `Supplied ${e} is not a${s?"n":""} ${t}.`,
            WEBHOOK_MESSAGE: "The message was not sent by a webhook.",
            EMOJI_TYPE: "Emoji must be a string or GuildEmoji/ReactionEmoji",
            EMOJI_MANAGED: "Emoji is managed and has no Author.",
            MISSING_MANAGE_EMOJIS_PERMISSION: e => `Client must have Manage Emoji permission in guild ${e} to see emoji authors.`,
            REACTION_RESOLVE_USER: "Couldn't resolve the user ID to remove from the reaction.",
            VANITY_URL: "This guild does not have the VANITY_URL feature enabled.",
            DELETE_GROUP_DM_CHANNEL: "Bots don't have access to Group DM Channels and cannot delete them",
            FETCH_GROUP_DM_CHANNEL: "Bots don't have access to Group DM Channels and cannot fetch them"
        };
        for (const [e, t] of Object.entries(n)) i(e, t)
    }, function (e, t, s) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        class Collection extends Map {
            constructor(e) {
                super(e), Object.defineProperty(this, "_array", {
                    value: null,
                    writable: !0,
                    configurable: !0
                }), Object.defineProperty(this, "_keyArray", {
                    value: null,
                    writable: !0,
                    configurable: !0
                })
            }
            get(e) {
                return super.get(e)
            }
            set(e, t) {
                return this._array = null, this._keyArray = null, super.set(e, t)
            }
            has(e) {
                return super.has(e)
            }
            delete(e) {
                return this._array = null, this._keyArray = null, super.delete(e)
            }
            clear() {
                return super.clear()
            }
            array() {
                return this._array && this._array.length === this.size || (this._array = [...this.values()]), this._array
            }
            keyArray() {
                return this._keyArray && this._keyArray.length === this.size || (this._keyArray = [...this.keys()]), this._keyArray
            }
            first(e) {
                if (void 0 === e) return this.values().next().value;
                if (e < 0) return this.last(-1 * e);
                e = Math.min(this.size, e);
                const t = this.values();
                return Array.from({
                    length: e
                }, () => t.next().value)
            }
            firstKey(e) {
                if (void 0 === e) return this.keys().next().value;
                if (e < 0) return this.lastKey(-1 * e);
                e = Math.min(this.size, e);
                const t = this.keys();
                return Array.from({
                    length: e
                }, () => t.next().value)
            }
            last(e) {
                const t = this.array();
                return void 0 === e ? t[t.length - 1] : e < 0 ? this.first(-1 * e) : e ? t.slice(-e) : []
            }
            lastKey(e) {
                const t = this.keyArray();
                return void 0 === e ? t[t.length - 1] : e < 0 ? this.firstKey(-1 * e) : e ? t.slice(-e) : []
            }
            random(e) {
                let t = this.array();
                return void 0 === e ? t[Math.floor(Math.random() * t.length)] : 0 !== t.length && e ? (t = t.slice(), Array.from({
                    length: e
                }, () => t.splice(Math.floor(Math.random() * t.length), 1)[0])) : []
            }
            randomKey(e) {
                let t = this.keyArray();
                return void 0 === e ? t[Math.floor(Math.random() * t.length)] : 0 !== t.length && e ? (t = t.slice(), Array.from({
                    length: e
                }, () => t.splice(Math.floor(Math.random() * t.length), 1)[0])) : []
            }
            find(e, t) {
                void 0 !== t && (e = e.bind(t));
                for (const [t, s] of this)
                    if (e(s, t, this)) return s
            }
            findKey(e, t) {
                void 0 !== t && (e = e.bind(t));
                for (const [t, s] of this)
                    if (e(s, t, this)) return t
            }
            sweep(e, t) {
                void 0 !== t && (e = e.bind(t));
                const s = this.size;
                for (const [t, s] of this) e(s, t, this) && this.delete(t);
                return s - this.size
            }
            filter(e, t) {
                void 0 !== t && (e = e.bind(t));
                const s = new this.constructor[Symbol.species];
                for (const [t, i] of this) e(i, t, this) && s.set(t, i);
                return s
            }
            partition(e, t) {
                void 0 !== t && (e = e.bind(t));
                const s = [new this.constructor[Symbol.species], new this.constructor[Symbol.species]];
                for (const [t, i] of this) e(i, t, this) ? s[0].set(t, i) : s[1].set(t, i);
                return s
            }
            flatMap(e, t) {
                const s = this.map(e, t);
                return (new this.constructor[Symbol.species]).concat(...s)
            }
            map(e, t) {
                void 0 !== t && (e = e.bind(t));
                const s = this.entries();
                return Array.from({
                    length: this.size
                }, () => {
                    const [t, i] = s.next().value;
                    return e(i, t, this)
                })
            }
            mapValues(e, t) {
                void 0 !== t && (e = e.bind(t));
                const s = new this.constructor[Symbol.species];
                for (const [t, i] of this) s.set(t, e(i, t, this));
                return s
            }
            some(e, t) {
                void 0 !== t && (e = e.bind(t));
                for (const [t, s] of this)
                    if (e(s, t, this)) return !0;
                return !1
            }
            every(e, t) {
                void 0 !== t && (e = e.bind(t));
                for (const [t, s] of this)
                    if (!e(s, t, this)) return !1;
                return !0
            }
            reduce(e, t) {
                let s;
                if (void 0 !== t) {
                    s = t;
                    for (const [t, i] of this) s = e(s, i, t, this);
                    return s
                }
                let i = !0;
                for (const [t, n] of this) i ? (s = n, i = !1) : s = e(s, n, t, this);
                if (i) throw new TypeError("Reduce of empty collection with no initial value");
                return s
            }
            each(e, t) {
                return this.forEach(e, t), this
            }
            tap(e, t) {
                return void 0 !== t && (e = e.bind(t)), e(this), this
            }
            clone() {
                return new this.constructor[Symbol.species](this)
            }
            concat(...e) {
                const t = this.clone();
                for (const s of e)
                    for (const [e, i] of s) t.set(e, i);
                return t
            }
            equals(e) {
                if (!e) return !1;
                if (this === e) return !0;
                if (this.size !== e.size) return !1;
                for (const [t, s] of this)
                    if (!e.has(t) || s !== e.get(t)) return !1;
                return !0
            }
            sort(e = ((e, t) => Number(e > t) || Number(e === t) - 1)) {
                const t = [...this.entries()];
                t.sort((t, s) => e(t[1], s[1], t[0], s[0])), super.clear(), this._array = null, this._keyArray = null;
                for (const [e, s] of t) super.set(e, s);
                return this
            }
            intersect(e) {
                return e.filter((e, t) => this.has(t))
            }
            difference(e) {
                return e.filter((e, t) => !this.has(t)).concat(this.filter((t, s) => !e.has(s)))
            }
            sorted(e = ((e, t) => Number(e > t) || Number(e === t) - 1)) {
                return new this.constructor[Symbol.species]([...this.entries()]).sort((t, s, i, n) => e(t, s, i, n))
            }
        }
        t.Collection = Collection, Collection.default = Collection, t.default = Collection, e.exports = Collection
    }, function (e, t, s) {
        "use strict";
        const i = s(87),
            n = s(91),
            r = s(92),
            {
                Error: o
            } = s(3),
            a = s(2),
            {
                Endpoints: c
            } = s(0);
        e.exports = class RESTManager {
            constructor(e, t = "Bot") {
                this.client = e, this.handlers = new a, this.tokenPrefix = t, this.versioned = !0, this.globalTimeout = null, e.options.restSweepInterval > 0 && e.setInterval(() => {
                    this.handlers.sweep(e => e._inactive)
                }, 1e3 * e.options.restSweepInterval)
            }
            get api() {
                return n(this)
            }
            getAuth() {
                const e = this.client.token || this.client.accessToken;
                if (e) return `${this.tokenPrefix} ${e}`;
                throw new o("TOKEN_MISSING")
            }
            get cdn() {
                return c.CDN(this.client.options.http.cdn)
            }
            push(e, t) {
                return new Promise((s, i) => {
                    e.push({
                        request: t,
                        resolve: s,
                        reject: i,
                        retries: 0
                    }).catch(i)
                })
            }
            request(e, t, s = {}) {
                const n = new i(this, e, t, s);
                let o = this.handlers.get(n.route);
                return o || (o = new r(this), this.handlers.set(n.route, o)), this.push(o, n)
            }
            set endpoint(e) {
                this.client.options.http.api = e
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(88),
            n = s(89),
            r = s(90),
            o = s(30),
            {
                browser: a,
                UserAgent: c
            } = s(0);
        if (i.Agent) var l = new i.Agent({
            keepAlive: !0
        });
        e.exports = class APIRequest {
            constructor(e, t, s, i) {
                this.rest = e, this.client = e.client, this.method = t, this.route = i.route, this.options = i;
                let n = "";
                if (i.query) {
                    const e = Object.entries(i.query).filter(([, e]) => null != e);
                    n = new URLSearchParams(e).toString()
                }
                this.path = `${s}${n&&`?${n}`}`
            }
            make() {
                const e = (!1 === this.options.versioned ? this.client.options.http.api : `${this.client.options.http.api}/v${this.client.options.http.version}`) + this.path;
                let t, s = {};
                if (!1 !== this.options.auth && (s.Authorization = this.rest.getAuth()), this.options.reason && (s["X-Audit-Log-Reason"] = encodeURIComponent(this.options.reason)), a || (s["User-Agent"] = c), this.options.headers && (s = Object.assign(s, this.options.headers)), this.options.files && this.options.files.length) {
                    t = new r;
                    for (const e of this.options.files) e && e.file && t.append(e.name, e.file, e.name);
                    void 0 !== this.options.data && t.append("payload_json", JSON.stringify(this.options.data)), a || (s = Object.assign(s, t.getHeaders()))
                } else null != this.options.data && (t = JSON.stringify(this.options.data), s["Content-Type"] = "application/json");
                const i = new n,
                    h = this.client.setTimeout(() => i.abort(), this.client.options.restRequestTimeout);
                return o(e, {
                    method: this.method,
                    headers: s,
                    agent: l,
                    body: t,
                    signal: i.signal
                }).finally(() => this.client.clearTimeout(h))
            }
        }
    }, function (e, t) {}, function (e, t, s) {
        "use strict";
        const {
            AbortController: i,
            AbortSignal: n
        } = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0;
        e.exports = i, e.exports.AbortSignal = n, e.exports.default = i
    }, function (e, t) {
        e.exports = "object" == typeof self ? self.FormData : window.FormData
    }, function (e, t, s) {
        "use strict";
        const i = () => {},
            n = ["get", "post", "delete", "patch", "put"],
            r = ["toString", "valueOf", "inspect", "constructor", Symbol.toPrimitive, Symbol.for("nodejs.util.inspect.custom")];
        e.exports = function (e) {
            const t = [""],
                s = {
                    get(o, a) {
                        if (r.includes(a)) return () => t.join("/");
                        if (n.includes(a)) {
                            const s = [];
                            for (let e = 0; e < t.length && "reactions" !== t[e - 1]; e++) /\d{16,19}/g.test(t[e]) && !/channels|guilds/.test(t[e - 1]) ? s.push(":id") : s.push(t[e]);
                            return i => e.request(a, t.join("/"), Object.assign({
                                versioned: e.versioned,
                                route: s.join("/")
                            }, i))
                        }
                        return t.push(a), new Proxy(i, s)
                    },
                    apply: (e, n, r) => (t.push(...r.filter(e => null != e)), new Proxy(i, s))
                };
            return new Proxy(i, s)
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(54),
            n = s(55),
            {
                Events: {
                    RATE_LIMIT: r
                },
                browser: o
            } = s(0),
            a = s(4);

        function c(e) {
            return e.headers.get("content-type").startsWith("application/json") ? e.json() : o ? e.blob() : e.buffer()
        }

        function l(e) {
            return new Date(e).getTime() - Date.now()
        }
        e.exports = class RequestHandler {
            constructor(e) {
                this.manager = e, this.busy = !1, this.queue = [], this.reset = -1, this.remaining = -1, this.limit = -1, this.retryAfter = -1
            }
            push(e) {
                return this.busy ? (this.queue.push(e), this.run()) : this.execute(e)
            }
            run() {
                return 0 === this.queue.length ? Promise.resolve() : this.execute(this.queue.shift())
            }
            get limited() {
                return Boolean(this.manager.globalTimeout) || this.remaining <= 0 && Date.now() < this.reset
            }
            get _inactive() {
                return 0 === this.queue.length && !this.limited && !0 !== this.busy
            }
            async execute(e) {
                if (this.busy) return this.queue.unshift(e), null;
                this.busy = !0;
                const {
                    reject: t,
                    request: s,
                    resolve: o
                } = e;
                if (this.limited) {
                    const e = this.reset + this.manager.client.options.restTimeOffset - Date.now();
                    this.manager.client.listenerCount(r) && this.manager.client.emit(r, {
                        timeout: e,
                        limit: this.limit,
                        method: s.method,
                        path: s.path,
                        route: s.route
                    }), this.manager.globalTimeout ? await this.manager.globalTimeout : await a.delayFor(e)
                }
                let h;
                try {
                    h = await s.make()
                } catch (e) {
                    return this.busy = !1, t(new n(e.message, e.constructor.name, e.status, s.method, s.path))
                }
                if (h && h.headers) {
                    const t = h.headers.get("date"),
                        s = h.headers.get("x-ratelimit-limit"),
                        i = h.headers.get("x-ratelimit-remaining"),
                        n = h.headers.get("x-ratelimit-reset"),
                        r = h.headers.get("retry-after");
                    this.limit = s ? Number(s) : 1 / 0, this.remaining = i ? Number(i) : 1, this.reset = n ? function (e, t) {
                        return new Date(1e3 * Number(e)).getTime() - l(t)
                    }(n, t) : Date.now(), this.retryAfter = r ? Number(r) : -1, e.request.route.includes("reactions") && (this.reset = new Date(t).getTime() - l(t) + 250), h.headers.get("x-ratelimit-global") && (this.manager.globalTimeout = a.delayFor(this.retryAfter), await this.manager.globalTimeout, this.manager.globalTimeout = null)
                }
                if (this.busy = !1, h.ok) {
                    return o(await c(h)), this.run()
                }
                if (429 === h.status) return this.queue.unshift(e), this.manager.client.emit("debug", `429 hit on route ${e.request.route}`), await a.delayFor(this.retryAfter), this.run();
                if (h.status >= 500 && h.status < 600) return e.retries === this.manager.client.options.retryLimit ? t(new n(h.statusText, h.constructor.name, h.status, e.request.method, s.path)) : (e.retries++, this.queue.unshift(e), this.run());
                try {
                    const e = await c(h);
                    return h.status >= 400 && h.status < 500 ? t(new i(s.path, e, s.method, h.status)) : null
                } catch (e) {
                    return t(new n(e.message, e.constructor.name, e.status, s.method, s.path))
                }
            }
        }
    }, function (module, exports, __webpack_require__) {
        "use strict";
        (function (process) {
            const BaseClient = __webpack_require__(31),
                ActionsManager = __webpack_require__(94),
                ClientVoiceManager = __webpack_require__(131),
                WebSocketManager = __webpack_require__(132),
                {
                    Error: Error,
                    TypeError: TypeError,
                    RangeError: RangeError
                } = __webpack_require__(3),
                ChannelManager = __webpack_require__(79),
                GuildEmojiManager = __webpack_require__(48),
                GuildManager = __webpack_require__(80),
                UserManager = __webpack_require__(81),
                ShardClientUtil = __webpack_require__(177),
                ClientApplication = __webpack_require__(41),
                GuildPreview = __webpack_require__(46),
                Invite = __webpack_require__(16),
                VoiceRegion = __webpack_require__(47),
                Webhook = __webpack_require__(11),
                Collection = __webpack_require__(2),
                {
                    Events: Events,
                    browser: browser,
                    DefaultOptions: DefaultOptions
                } = __webpack_require__(0),
                DataResolver = __webpack_require__(9),
                Intents = __webpack_require__(82),
                Permissions = __webpack_require__(8),
                Structures = __webpack_require__(18);
            class Client extends BaseClient {
                constructor(e = {}) {
                    super(Object.assign({
                        _tokenType: "Bot"
                    }, e));
                    let t = process.env;
                    try {
                        t = __webpack_require__(178).workerData || t
                    } catch {}
                    this.options.shards === DefaultOptions.shards && "SHARDS" in t && (this.options.shards = JSON.parse(t.SHARDS)), this.options.shardCount === DefaultOptions.shardCount && ("SHARD_COUNT" in t ? this.options.shardCount = Number(t.SHARD_COUNT) : Array.isArray(this.options.shards) && (this.options.shardCount = this.options.shards.length));
                    const s = typeof this.options.shards;
                    "undefined" === s && "number" == typeof this.options.shardCount && (this.options.shards = Array.from({
                        length: this.options.shardCount
                    }, (e, t) => t)), "number" === s && (this.options.shards = [this.options.shards]), Array.isArray(this.options.shards) && (this.options.shards = [...new Set(this.options.shards.filter(e => !isNaN(e) && e >= 0 && e < 1 / 0 && e === (0 | e)))]), this._validateOptions(), this.ws = new WebSocketManager(this), this.actions = new ActionsManager(this), this.voice = browser ? null : new ClientVoiceManager(this), this.shard = !browser && process.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE) : null, this.users = new UserManager(this), this.guilds = new GuildManager(this), this.channels = new ChannelManager(this);
                    const i = Structures.get("ClientPresence");
                    this.presence = new i(this), Object.defineProperty(this, "token", {
                        writable: !0
                    }), browser || this.token || !("DISCORD_TOKEN" in process.env) ? this.token = null : this.token = process.env.DISCORD_TOKEN, this.user = null, this.readyAt = null, this.options.messageSweepInterval > 0 && this.setInterval(this.sweepMessages.bind(this), 1e3 * this.options.messageSweepInterval)
                }
                get emojis() {
                    const e = new GuildEmojiManager({
                        client: this
                    });
                    for (const t of this.guilds.cache.values())
                        if (t.available)
                            for (const s of t.emojis.cache.values()) e.cache.set(s.id, s);
                    return e
                }
                get readyTimestamp() {
                    return this.readyAt ? this.readyAt.getTime() : null
                }
                get uptime() {
                    return this.readyAt ? Date.now() - this.readyAt : null
                }
                async login(e = this.token) {
                    if (!e || "string" != typeof e) throw new Error("TOKEN_INVALID");
                    this.token = e = e.replace(/^(Bot|Bearer)\s*/i, ""), this.emit(Events.DEBUG, `Provided token: ${e.split(".").map((e,t)=>t>1?e.replace(/./g,"*"):e).join(".")}`), this.options.presence && (this.options.ws.presence = await this.presence._parse(this.options.presence)), this.emit(Events.DEBUG, "Preparing to connect to the gateway...");
                    try {
                        return await this.ws.connect(), this.token
                    } catch (e) {
                        throw this.destroy(), e
                    }
                }
                destroy() {
                    super.destroy(), this.ws.destroy(), this.token = null
                }
                fetchInvite(e) {
                    const t = DataResolver.resolveInviteCode(e);
                    return this.api.invites(t).get({
                        query: {
                            with_counts: !0
                        }
                    }).then(e => new Invite(this, e))
                }
                fetchWebhook(e, t) {
                    return this.api.webhooks(e, t).get().then(e => new Webhook(this, e))
                }
                fetchVoiceRegions() {
                    return this.api.voice.regions.get().then(e => {
                        const t = new Collection;
                        for (const s of e) t.set(s.id, new VoiceRegion(s));
                        return t
                    })
                }
                sweepMessages(e = this.options.messageCacheLifetime) {
                    if ("number" != typeof e || isNaN(e)) throw new TypeError("INVALID_TYPE", "lifetime", "number");
                    if (e <= 0) return this.emit(Events.DEBUG, "Didn't sweep messages - lifetime is unlimited"), -1;
                    const t = 1e3 * e,
                        s = Date.now();
                    let i = 0,
                        n = 0;
                    for (const e of this.channels.cache.values()) e.messages && (i++, n += e.messages.cache.sweep(e => s - (e.editedTimestamp || e.createdTimestamp) > t));
                    return this.emit(Events.DEBUG, `Swept ${n} messages older than ${e} seconds in ${i} text-based channels`), n
                }
                fetchApplication() {
                    return this.api.oauth2.applications("@me").get().then(e => new ClientApplication(this, e))
                }
                fetchGuildPreview(e) {
                    const t = this.guilds.resolveID(e);
                    if (!t) throw new TypeError("INVALID_TYPE", "guild", "GuildResolvable");
                    return this.api.guilds(t).preview.get().then(e => new GuildPreview(this, e))
                }
                async generateInvite(e) {
                    e = Permissions.resolve(e);
                    const t = await this.fetchApplication(),
                        s = new URLSearchParams({
                            client_id: t.id,
                            permissions: e,
                            scope: "bot"
                        });
                    return `${this.options.http.api}${this.api.oauth2.authorize}?${s}`
                }
                toJSON() {
                    return super.toJSON({
                        readyAt: !1,
                        presences: !1
                    })
                }
                _eval(script) {
                    return eval(script)
                }
                _validateOptions(e = this.options) {
                    if (void 0 !== e.ws.intents && (e.ws.intents = Intents.resolve(e.ws.intents)), "number" != typeof e.shardCount || isNaN(e.shardCount) || e.shardCount < 1) throw new TypeError("CLIENT_INVALID_OPTION", "shardCount", "a number greater than or equal to 1");
                    if (e.shards && "auto" !== e.shards && !Array.isArray(e.shards)) throw new TypeError("CLIENT_INVALID_OPTION", "shards", "'auto', a number or array of numbers");
                    if (e.shards && !e.shards.length) throw new RangeError("CLIENT_INVALID_PROVIDED_SHARDS");
                    if ("number" != typeof e.messageCacheMaxSize || isNaN(e.messageCacheMaxSize)) throw new TypeError("CLIENT_INVALID_OPTION", "messageCacheMaxSize", "a number");
                    if ("number" != typeof e.messageCacheLifetime || isNaN(e.messageCacheLifetime)) throw new TypeError("CLIENT_INVALID_OPTION", "The messageCacheLifetime", "a number");
                    if ("number" != typeof e.messageSweepInterval || isNaN(e.messageSweepInterval)) throw new TypeError("CLIENT_INVALID_OPTION", "messageSweepInterval", "a number");
                    if ("boolean" != typeof e.fetchAllMembers) throw new TypeError("CLIENT_INVALID_OPTION", "fetchAllMembers", "a boolean");
                    if ("string" != typeof e.disableMentions) throw new TypeError("CLIENT_INVALID_OPTION", "disableMentions", "a string");
                    if (!Array.isArray(e.partials)) throw new TypeError("CLIENT_INVALID_OPTION", "partials", "an Array");
                    if ("number" != typeof e.restWsBridgeTimeout || isNaN(e.restWsBridgeTimeout)) throw new TypeError("CLIENT_INVALID_OPTION", "restWsBridgeTimeout", "a number");
                    if ("number" != typeof e.restRequestTimeout || isNaN(e.restRequestTimeout)) throw new TypeError("CLIENT_INVALID_OPTION", "restRequestTimeout", "a number");
                    if ("number" != typeof e.restSweepInterval || isNaN(e.restSweepInterval)) throw new TypeError("CLIENT_INVALID_OPTION", "restSweepInterval", "a number");
                    if ("number" != typeof e.retryLimit || isNaN(e.retryLimit)) throw new TypeError("CLIENT_INVALID_OPTION", "retryLimit", "a number")
                }
            }
            module.exports = Client
        }).call(this, __webpack_require__(23))
    }, function (e, t, s) {
        "use strict";
        e.exports = class ActionsManager {
            constructor(e) {
                this.client = e, this.register(s(95)), this.register(s(96)), this.register(s(97)), this.register(s(98)), this.register(s(99)), this.register(s(100)), this.register(s(101)), this.register(s(102)), this.register(s(103)), this.register(s(104)), this.register(s(110)), this.register(s(111)), this.register(s(112)), this.register(s(113)), this.register(s(114)), this.register(s(115)), this.register(s(116)), this.register(s(117)), this.register(s(118)), this.register(s(119)), this.register(s(120)), this.register(s(121)), this.register(s(122)), this.register(s(123)), this.register(s(124)), this.register(s(125)), this.register(s(126)), this.register(s(127)), this.register(s(128)), this.register(s(129)), this.register(s(130))
            }
            register(e) {
                this[e.name.replace(/Action$/, "")] = new e(this.client)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class MessageCreateAction extends i {
            handle(e) {
                const t = this.client,
                    s = t.channels.cache.get(e.channel_id);
                if (s) {
                    const i = s.messages.cache.get(e.id);
                    if (i) return {
                        message: i
                    };
                    const r = s.messages.add(e),
                        o = r.author;
                    let a = r.member;
                    return s.lastMessageID = e.id, o && (o.lastMessageID = e.id, o.lastMessageChannelID = s.id), a && (a.lastMessageID = e.id, a.lastMessageChannelID = s.id), t.emit(n.MESSAGE_CREATE, r), {
                        message: r
                    }
                }
                return {}
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class MessageDeleteAction extends i {
            handle(e) {
                const t = this.client,
                    s = this.getChannel(e);
                let i;
                return s && (i = this.getMessage(e, s), i && (s.messages.cache.delete(i.id), i.deleted = !0, t.emit(n.MESSAGE_DELETE, i))), {
                    message: i
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            n = s(2),
            {
                Events: r
            } = s(0);
        e.exports = class MessageDeleteBulkAction extends i {
            handle(e) {
                const t = this.client,
                    s = t.channels.cache.get(e.channel_id);
                if (s) {
                    const i = e.ids,
                        o = new n;
                    for (const t of i) {
                        const i = this.getMessage({
                            id: t,
                            guild_id: e.guild_id
                        }, s, !1);
                        i && (i.deleted = !0, o.set(i.id, i), s.messages.cache.delete(t))
                    }
                    return o.size > 0 && t.emit(r.MESSAGE_BULK_DELETE, o), {
                        messages: o
                    }
                }
                return {}
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1);
        e.exports = class MessageUpdateAction extends i {
            handle(e) {
                const t = this.getChannel(e);
                if (t) {
                    const {
                        id: s,
                        channel_id: i,
                        guild_id: n,
                        author: r,
                        timestamp: o,
                        type: a
                    } = e, c = this.getMessage({
                        id: s,
                        channel_id: i,
                        guild_id: n,
                        author: r,
                        timestamp: o,
                        type: a
                    }, t);
                    if (c) return c.patch(e), {
                        old: c._edits[0],
                        updated: c
                    }
                }
                return {}
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0),
            {
                PartialTypes: r
            } = s(0);
        e.exports = class MessageReactionAdd extends i {
            handle(e) {
                if (!e.emoji) return !1;
                const t = this.getUser(e);
                if (!t) return !1;
                const s = this.getChannel(e);
                if (!s || "voice" === s.type) return !1;
                const i = this.getMessage(e, s);
                if (!i) return !1;
                if (i.partial && !this.client.options.partials.includes(r.REACTION)) return !1;
                const o = i.reactions.add({
                    emoji: e.emoji,
                    count: i.partial ? null : 0,
                    me: t.id === this.client.user.id
                });
                return !!o && (o._add(t), this.client.emit(n.MESSAGE_REACTION_ADD, o, t), {
                    message: i,
                    reaction: o,
                    user: t
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class MessageReactionRemove extends i {
            handle(e) {
                if (!e.emoji) return !1;
                const t = this.getUser(e);
                if (!t) return !1;
                const s = this.getChannel(e);
                if (!s || "voice" === s.type) return !1;
                const i = this.getMessage(e, s);
                if (!i) return !1;
                const r = this.getReaction(e, i, t);
                return !!r && (r._remove(t), this.client.emit(n.MESSAGE_REACTION_REMOVE, r, t), {
                    message: i,
                    reaction: r,
                    user: t
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class MessageReactionRemoveAll extends i {
            handle(e) {
                const t = this.getChannel(e);
                if (!t || "voice" === t.type) return !1;
                const s = this.getMessage(e, t);
                return !!s && (s.reactions.cache.clear(), this.client.emit(n.MESSAGE_REACTION_REMOVE_ALL, s), {
                    message: s
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class MessageReactionRemoveEmoji extends i {
            handle(e) {
                const t = this.getChannel(e);
                if (!t || "voice" === t.type) return !1;
                const s = this.getMessage(e, t);
                if (!s) return !1;
                const i = this.getReaction(e, s);
                return !!i && (s.partial || s.reactions.cache.delete(i.emoji.id || i.emoji.name), this.client.emit(n.MESSAGE_REACTION_REMOVE_EMOJI, i), {
                    reaction: i
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class ChannelCreateAction extends i {
            handle(e) {
                const t = this.client,
                    s = t.channels.cache.has(e.id),
                    i = t.channels.add(e);
                return !s && i && t.emit(n.CHANNEL_CREATE, i), {
                    channel: i
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            n = s(32),
            {
                Events: r
            } = s(0);
        e.exports = class ChannelDeleteAction extends i {
            constructor(e) {
                super(e), this.deleted = new Map
            }
            handle(e) {
                const t = this.client;
                let s = t.channels.cache.get(e.id);
                if (s) {
                    if (t.channels.remove(s.id), s.deleted = !0, s.messages && !(s instanceof n))
                        for (const e of s.messages.cache.values()) e.deleted = !0;
                    t.emit(r.CHANNEL_DELETE, s)
                }
                return {
                    channel: s
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            n = s(42);
        e.exports = class ReactionManager extends i {
            constructor(e, t) {
                super(e.client, t, n), this.message = e
            }
            add(e, t) {
                return super.add(e, t, {
                    id: e.emoji.id || e.emoji.name,
                    extras: [this.message]
                })
            }
            removeAll() {
                return this.client.api.channels(this.message.channel.id).messages(this.message.id).reactions.delete().then(() => this.message)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(2);
        e.exports = class LimitedCollection extends i {
            constructor(e = 0, t = null) {
                super(t), this.maxSize = e
            }
            set(e, t) {
                return 0 === this.maxSize ? this : (this.size >= this.maxSize && !this.has(e) && this.delete(this.firstKey()), super.set(e, t))
            }
            static get[Symbol.species]() {
                return i
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(33);
        e.exports = class GuildPreviewEmoji extends i {
            get roles() {
                return new Set(this._roles)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(6),
            n = s(21);
        e.exports = class VoiceStateManager extends i {
            constructor(e, t) {
                super(e.client, t, n), this.guild = e
            }
            add(e, t = !0) {
                const s = this.cache.get(e.user_id);
                if (s) return s._patch(e);
                const i = new n(this.guild, e);
                return t && this.cache.set(e.user_id, i), i
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(13),
            {
                Error: n
            } = s(3);
        e.exports = class PartialGroupDMChannel extends i {
            constructor(e, t) {
                super(e, t), this.name = t.name, this.icon = t.icon
            }
            iconURL({
                format: e,
                size: t
            } = {}) {
                return this.icon ? this.client.rest.cdn.GDMIcon(this.id, this.icon, e, t) : null
            }
            delete() {
                return Promise.reject(new n("DELETE_GROUP_DM_CHANNEL"))
            }
            fetch() {
                return Promise.reject(new n("FETCH_GROUP_DM_CHANNEL"))
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            n = s(13),
            {
                ChannelTypes: r
            } = s(0);
        e.exports = class ChannelUpdateAction extends i {
            handle(e) {
                let t = this.client.channels.cache.get(e.id);
                if (t) {
                    const s = t._update(e);
                    if (r[t.type.toUpperCase()] !== e.type) {
                        const s = n.create(this.client, e, t.guild);
                        for (const [e, i] of t.messages.cache) s.messages.cache.set(e, i);
                        s._typing = new Map(t._typing), t = s, this.client.channels.cache.set(t.id, t)
                    }
                    return {
                        old: s,
                        updated: t
                    }
                }
                return {}
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class GuildDeleteAction extends i {
            constructor(e) {
                super(e), this.deleted = new Map
            }
            handle(e) {
                const t = this.client;
                let s = t.guilds.cache.get(e.id);
                if (s) {
                    for (const e of s.channels.cache.values()) "text" === e.type && e.stopTyping(!0);
                    if (e.unavailable) return s.available = !1, t.emit(n.GUILD_UNAVAILABLE, s), {
                        guild: null
                    };
                    for (const e of s.channels.cache.values()) this.client.channels.remove(e.id);
                    s.voice && s.voice.connection && s.voice.connection.disconnect(), t.guilds.cache.delete(s.id), s.deleted = !0, t.emit(n.GUILD_DELETE, s), this.deleted.set(s.id, s), this.scheduleForDeletion(s.id)
                } else s = this.deleted.get(e.id) || null;
                return {
                    guild: s
                }
            }
            scheduleForDeletion(e) {
                this.client.setTimeout(() => this.deleted.delete(e), this.client.options.restWsBridgeTimeout)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class GuildUpdateAction extends i {
            handle(e) {
                const t = this.client,
                    s = t.guilds.cache.get(e.id);
                if (s) {
                    const i = s._update(e);
                    return t.emit(n.GUILD_UPDATE, i, s), {
                        old: i,
                        updated: s
                    }
                }
                return {
                    old: null,
                    updated: null
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            n = s(16),
            {
                Events: r
            } = s(0);
        e.exports = class InviteCreateAction extends i {
            handle(e) {
                const t = this.client,
                    s = t.channels.cache.get(e.channel_id),
                    i = t.guilds.cache.get(e.guild_id);
                if (!s && !i) return !1;
                const o = Object.assign(e, {
                        channel: s,
                        guild: i
                    }),
                    a = new n(t, o);
                return t.emit(r.INVITE_CREATE, a), {
                    invite: a
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            n = s(16),
            {
                Events: r
            } = s(0);
        e.exports = class InviteDeleteAction extends i {
            handle(e) {
                const t = this.client,
                    s = t.channels.cache.get(e.channel_id),
                    i = t.guilds.cache.get(e.guild_id);
                if (!s && !i) return !1;
                const o = Object.assign(e, {
                        channel: s,
                        guild: i
                    }),
                    a = new n(t, o);
                return t.emit(r.INVITE_DELETE, a), {
                    invite: a
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n,
                Status: r
            } = s(0);
        e.exports = class GuildMemberRemoveAction extends i {
            handle(e, t) {
                const s = this.client,
                    i = s.guilds.cache.get(e.guild_id);
                let o = null;
                return i && (o = this.getMember(e, i), i.memberCount--, o && (o.deleted = !0, i.members.cache.delete(o.id), t.status === r.READY && s.emit(n.GUILD_MEMBER_REMOVE, o)), i.voiceStates.cache.delete(e.user.id)), {
                    guild: i,
                    member: o
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class GuildBanRemove extends i {
            handle(e) {
                const t = this.client,
                    s = t.guilds.cache.get(e.guild_id),
                    i = t.users.add(e.user);
                s && i && t.emit(n.GUILD_BAN_REMOVE, s, i)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class GuildRoleCreate extends i {
            handle(e) {
                const t = this.client,
                    s = t.guilds.cache.get(e.guild_id);
                let i;
                if (s) {
                    const r = s.roles.cache.has(e.role.id);
                    i = s.roles.add(e.role), r || t.emit(n.GUILD_ROLE_CREATE, i)
                }
                return {
                    role: i
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class GuildRoleDeleteAction extends i {
            handle(e) {
                const t = this.client,
                    s = t.guilds.cache.get(e.guild_id);
                let i;
                return s && (i = s.roles.cache.get(e.role_id), i && (s.roles.cache.delete(e.role_id), i.deleted = !0, t.emit(n.GUILD_ROLE_DELETE, i))), {
                    role: i
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class GuildRoleUpdateAction extends i {
            handle(e) {
                const t = this.client,
                    s = t.guilds.cache.get(e.guild_id);
                if (s) {
                    let i = null;
                    const r = s.roles.cache.get(e.role.id);
                    return r && (i = r._update(e.role), t.emit(n.GUILD_ROLE_UPDATE, i, r)), {
                        old: i,
                        updated: r
                    }
                }
                return {
                    old: null,
                    updated: null
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class PresenceUpdateAction extends i {
            handle(e) {
                let t = this.client.users.cache.get(e.user.id);
                if (!t && e.user.username && (t = this.client.users.add(e.user)), !t) return;
                e.user && e.user.username && (t.equals(e.user) || this.client.actions.UserUpdate.handle(e.user));
                const s = this.client.guilds.cache.get(e.guild_id);
                if (!s) return;
                let i = s.presences.cache.get(t.id);
                i && (i = i._clone());
                let r = s.members.cache.get(t.id);
                r || "offline" === e.status || (r = s.members.add({
                    user: t,
                    roles: e.roles,
                    deaf: !1,
                    mute: !1
                }), this.client.emit(n.GUILD_MEMBER_AVAILABLE, r)), s.presences.add(Object.assign(e, {
                    guild: s
                })), r && this.client.listenerCount(n.PRESENCE_UPDATE) && this.client.emit(n.PRESENCE_UPDATE, i, r.presence)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class UserUpdateAction extends i {
            handle(e) {
                const t = this.client,
                    s = t.users.cache.get(e.id),
                    i = s._update(e);
                return i.equals(s) ? {
                    old: null,
                    updated: null
                } : (t.emit(n.USER_UPDATE, i, s), {
                    old: i,
                    updated: s
                })
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            n = s(21),
            {
                Events: r
            } = s(0);
        e.exports = class VoiceStateUpdate extends i {
            handle(e) {
                const t = this.client,
                    s = t.guilds.cache.get(e.guild_id);
                if (s) {
                    const i = s.voiceStates.cache.has(e.user_id) ? s.voiceStates.cache.get(e.user_id)._clone() : new n(s, {
                            user_id: e.user_id
                        }),
                        o = s.voiceStates.add(e);
                    let a = s.members.cache.get(e.user_id);
                    a && e.member ? a._patch(e.member) : e.member && e.member.user && e.member.joined_at && (a = s.members.add(e.member)), a && a.user.id === t.user.id && (t.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(e)}`), t.voice.onVoiceStateUpdate(e)), t.emit(r.VOICE_STATE_UPDATE, i, o)
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class GuildEmojiCreateAction extends i {
            handle(e, t) {
                const s = e.emojis.add(t);
                return this.client.emit(n.GUILD_EMOJI_CREATE, s), {
                    emoji: s
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class GuildEmojiDeleteAction extends i {
            handle(e) {
                return e.guild.emojis.cache.delete(e.id), e.deleted = !0, this.client.emit(n.GUILD_EMOJI_DELETE, e), {
                    emoji: e
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class GuildEmojiUpdateAction extends i {
            handle(e, t) {
                const s = e._update(t);
                return this.client.emit(n.GUILD_EMOJI_UPDATE, s, e), {
                    emoji: e
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1);
        e.exports = class GuildEmojisUpdateAction extends i {
            handle(e) {
                const t = this.client.guilds.cache.get(e.guild_id);
                if (!t || !t.emojis) return;
                const s = new Map(t.emojis.cache);
                for (const i of e.emojis) {
                    const e = t.emojis.cache.get(i.id);
                    e ? (s.delete(i.id), e.equals(i) || this.client.actions.GuildEmojiUpdate.handle(e, i)) : this.client.actions.GuildEmojiCreate.handle(t, i)
                }
                for (const e of s.values()) this.client.actions.GuildEmojiDelete.handle(e)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1);
        e.exports = class GuildRolesPositionUpdate extends i {
            handle(e) {
                const t = this.client.guilds.cache.get(e.guild_id);
                if (t)
                    for (const s of e.roles) {
                        const e = t.roles.cache.get(s.id);
                        e && (e.rawPosition = s.position)
                    }
                return {
                    guild: t
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1);
        e.exports = class GuildChannelsPositionUpdate extends i {
            handle(e) {
                const t = this.client.guilds.cache.get(e.guild_id);
                if (t)
                    for (const s of e.channels) {
                        const e = t.channels.cache.get(s.id);
                        e && (e.rawPosition = s.position)
                    }
                return {
                    guild: t
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class GuildIntegrationsUpdate extends i {
            handle(e) {
                const t = this.client,
                    s = t.guilds.cache.get(e.guild_id);
                s && t.emit(n.GUILD_INTEGRATIONS_UPDATE, s)
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(1),
            {
                Events: n
            } = s(0);
        e.exports = class WebhooksUpdate extends i {
            handle(e) {
                const t = this.client,
                    s = t.channels.cache.get(e.channel_id);
                s && t.emit(n.WEBHOOKS_UPDATE, s)
            }
        }
    }, function (e, t) {}, function (e, t, s) {
        "use strict";
        const i = s(24),
            n = s(133),
            r = s(77),
            {
                Error: o
            } = s(3),
            a = s(2),
            {
                Events: c,
                ShardEvents: l,
                Status: h,
                WSCodes: u,
                WSEvents: d
            } = s(0),
            p = s(4),
            m = [d.READY, d.RESUMED, d.GUILD_CREATE, d.GUILD_DELETE, d.GUILD_MEMBERS_CHUNK, d.GUILD_MEMBER_ADD, d.GUILD_MEMBER_REMOVE],
            g = Object.keys(u).slice(1).map(Number),
            E = [1e3, 4006, 4007];
        e.exports = class WebSocketManager extends i {
            constructor(e) {
                super(), Object.defineProperty(this, "client", {
                    value: e
                }), this.gateway = void 0, this.totalShards = this.client.options.shards.length, this.shards = new a, Object.defineProperty(this, "shardQueue", {
                    value: new Set,
                    writable: !0
                }), Object.defineProperty(this, "packetQueue", {
                    value: []
                }), this.status = h.IDLE, this.destroyed = !1, this.reconnecting = !1, this.sessionStartLimit = void 0
            }
            get ping() {
                return this.shards.reduce((e, t) => e + t.ping, 0) / this.shards.size
            }
            debug(e, t) {
                this.client.emit(c.DEBUG, `[WS => ${t?`Shard ${t.id}`:"Manager"}] ${e}`)
            }
            async connect() {
                const e = new o(u[4004]),
                    {
                        url: t,
                        shards: s,
                        session_start_limit: i
                    } = await this.client.api.gateway.bot.get().catch(t => {
                        throw 401 === t.httpStatus ? e : t
                    });
                this.sessionStartLimit = i;
                const {
                    total: r,
                    remaining: a,
                    reset_after: c
                } = i;
                this.debug(`Fetched Gateway Information\n    URL: ${t}\n    Recommended Shards: ${s}`), this.debug(`Session Limit Information\n    Total: ${r}\n    Remaining: ${a}`), this.gateway = `${t}/`;
                let {
                    shards: l
                } = this.client.options;
                return "auto" === l && (this.debug(`Using the recommended shard count provided by Discord: ${s}`), this.totalShards = this.client.options.shardCount = s, l = this.client.options.shards = Array.from({
                    length: s
                }, (e, t) => t)), this.totalShards = l.length, this.debug(`Spawning shards: ${l.join(", ")}`), this.shardQueue = new Set(l.map(e => new n(this, e))), await this._handleSessionLimit(a, c), this.createShards()
            }
            async createShards() {
                if (!this.shardQueue.size) return !1;
                const [e] = this.shardQueue;
                this.shardQueue.delete(e), e.eventsAttached || (e.on(l.ALL_READY, t => {
                    this.client.emit(c.SHARD_READY, e.id, t), this.shardQueue.size || (this.reconnecting = !1), this.checkShardsReady()
                }), e.on(l.CLOSE, t => {
                    if (1e3 === t.code ? this.destroyed : g.includes(t.code)) return this.client.emit(c.SHARD_DISCONNECT, t, e.id), void this.debug(u[t.code], e);
                    E.includes(t.code) && (e.sessionID = void 0), this.client.emit(c.SHARD_RECONNECTING, e.id), this.shardQueue.add(e), e.sessionID ? (this.debug("Session ID is present, attempting an immediate reconnect...", e), this.reconnect(!0)) : (e.destroy({
                        reset: !0,
                        emit: !1,
                        log: !1
                    }), this.reconnect())
                }), e.on(l.INVALID_SESSION, () => {
                    this.client.emit(c.SHARD_RECONNECTING, e.id)
                }), e.on(l.DESTROYED, () => {
                    this.debug("Shard was destroyed but no WebSocket connection was present! Reconnecting...", e), this.client.emit(c.SHARD_RECONNECTING, e.id), this.shardQueue.add(e), this.reconnect()
                }), e.eventsAttached = !0), this.shards.set(e.id, e);
                try {
                    await e.connect()
                } catch (t) {
                    if (t && t.code && g.includes(t.code)) throw new o(u[t.code]);
                    if (t && !t.code) throw t;
                    this.debug("Failed to connect to the gateway, requeueing...", e), this.shardQueue.add(e)
                }
                return !this.shardQueue.size || (this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`), await p.delayFor(5e3), await this._handleSessionLimit(), this.createShards())
            }
            async reconnect(e = !1) {
                if (this.reconnecting || this.status !== h.READY) return !1;
                this.reconnecting = !0;
                try {
                    e || await this._handleSessionLimit(), await this.createShards()
                } catch (e) {
                    if (this.debug(`Couldn't reconnect or fetch information about the gateway. ${e}`), 401 !== e.httpStatus) return this.debug("Possible network error occurred. Retrying in 5s..."), await p.delayFor(5e3), this.reconnecting = !1, this.reconnect();
                    this.client.listenerCount(c.INVALIDATED) ? (this.client.emit(c.INVALIDATED), this.destroy()) : this.client.destroy()
                } finally {
                    this.reconnecting = !1
                }
                return !0
            }
            broadcast(e) {
                for (const t of this.shards.values()) t.send(e)
            }
            destroy() {
                if (!this.destroyed) {
                    this.debug(`Manager was destroyed. Called by:\n${new Error("MANAGER_DESTROYED").stack}`), this.destroyed = !0, this.shardQueue.clear();
                    for (const e of this.shards.values()) e.destroy({
                        closeCode: 1e3,
                        reset: !0,
                        emit: !1,
                        log: !1
                    })
                }
            }
            async _handleSessionLimit(e, t) {
                if (void 0 === e && void 0 === t) {
                    const {
                        session_start_limit: s
                    } = await this.client.api.gateway.bot.get();
                    this.sessionStartLimit = s, e = s.remaining, t = s.reset_after, this.debug(`Session Limit Information\n    Total: ${s.total}\n    Remaining: ${e}`)
                }
                e || (this.debug(`Exceeded identify threshold. Will attempt a connection in ${t}ms`), await p.delayFor(t))
            }
            handlePacket(e, t) {
                if (e && this.status !== h.READY && !m.includes(e.t)) return this.packetQueue.push({
                    packet: e,
                    shard: t
                }), !1;
                if (this.packetQueue.length) {
                    const e = this.packetQueue.shift();
                    this.client.setImmediate(() => {
                        this.handlePacket(e.packet, e.shard)
                    })
                }
                return e && r[e.t] && r[e.t](this.client, e, t), !0
            }
            async checkShardsReady() {
                if (this.status !== h.READY && this.shards.size === this.totalShards && !this.shards.some(e => e.status !== h.READY)) {
                    if (this.status = h.NEARLY, this.client.options.fetchAllMembers) try {
                        const e = this.client.guilds.cache.map(e => e.available ? e.members.fetch() : Promise.resolve());
                        await Promise.all(e)
                    } catch (e) {
                        this.debug(`Failed to fetch all members before ready! ${e}\n${e.stack}`)
                    }
                    this.triggerClientReady()
                }
            }
            triggerClientReady() {
                this.status = h.READY, this.client.readyAt = new Date, this.client.emit(c.CLIENT_READY), this.handlePacket()
            }
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(24),
            n = s(76),
            {
                browser: r,
                Status: o,
                Events: a,
                ShardEvents: c,
                OPCodes: l,
                WSEvents: h
            } = s(0),
            u = Object.keys(o),
            d = Object.keys(n.WebSocket);
        let p;
        if (!r) try {
            p = s(139)
        } catch {}
        e.exports = class WebSocketShard extends i {
            constructor(e, t) {
                super(), this.manager = e, this.id = t, this.status = o.IDLE, this.sequence = -1, this.closeSequence = 0, this.sessionID = void 0, this.ping = -1, this.lastPingTimestamp = -1, this.lastHeartbeatAcked = !0, Object.defineProperty(this, "ratelimit", {
                    value: {
                        queue: [],
                        total: 120,
                        remaining: 120,
                        time: 6e4,
                        timer: null
                    }
                }), Object.defineProperty(this, "connection", {
                    value: null,
                    writable: !0
                }), Object.defineProperty(this, "inflate", {
                    value: null,
                    writable: !0
                }), Object.defineProperty(this, "helloTimeout", {
                    value: void 0,
                    writable: !0
                }), Object.defineProperty(this, "eventsAttached", {
                    value: !1,
                    writable: !0
                }), Object.defineProperty(this, "expectedGuilds", {
                    value: void 0,
                    writable: !0
                }), Object.defineProperty(this, "readyTimeout", {
                    value: void 0,
                    writable: !0
                }), Object.defineProperty(this, "connectedAt", {
                    value: 0,
                    writable: !0
                })
            }
            debug(e) {
                this.manager.debug(e, this)
            }
            connect() {
                const {
                    gateway: e,
                    client: t
                } = this.manager;
                return this.connection && this.connection.readyState === n.OPEN && this.status === o.READY ? Promise.resolve() : new Promise((s, i) => {
                    const r = () => {
                            this.removeListener(c.CLOSE, h), this.removeListener(c.READY, a), this.removeListener(c.RESUMED, l), this.removeListener(c.INVALID_SESSION, u), this.removeListener(c.DESTROYED, u)
                        },
                        a = () => {
                            r(), s()
                        },
                        l = () => {
                            r(), s()
                        },
                        h = e => {
                            r(), i(e)
                        },
                        u = () => {
                            r(), i()
                        };
                    if (this.once(c.READY, a), this.once(c.RESUMED, l), this.once(c.CLOSE, h), this.once(c.INVALID_SESSION, u), this.once(c.DESTROYED, u), this.connection && this.connection.readyState === n.OPEN) return this.debug("An open connection was found, attempting an immediate identify."), void this.identify();
                    this.connection && (this.debug(`A connection object was found. Cleaning up before continuing.\n    State: ${d[this.connection.readyState]}`), this.destroy({
                        emit: !1
                    }));
                    const m = {
                        v: t.options.ws.version
                    };
                    p && (this.inflate = new p.Inflate({
                        chunkSize: 65535,
                        flush: p.Z_SYNC_FLUSH,
                        to: "json" === n.encoding ? "string" : ""
                    }), m.compress = "zlib-stream"), this.debug(`[CONNECT]\n    Gateway    : ${e}\n    Version    : ${t.options.ws.version}\n    Encoding   : ${n.encoding}\n    Compression: ${p?"zlib-stream":"none"}`), this.status = this.status === o.DISCONNECTED ? o.RECONNECTING : o.CONNECTING, this.setHelloTimeout(), this.connectedAt = Date.now();
                    const g = this.connection = n.create(e, m);
                    g.onopen = this.onOpen.bind(this), g.onmessage = this.onMessage.bind(this), g.onerror = this.onError.bind(this), g.onclose = this.onClose.bind(this)
                })
            }
            onOpen() {
                this.debug(`[CONNECTED] ${this.connection.url} in ${Date.now()-this.connectedAt}ms`), this.status = o.NEARLY
            }
            onMessage({
                data: e
            }) {
                let t, s;
                if (e instanceof ArrayBuffer && (e = new Uint8Array(e)), p) {
                    const s = e.length,
                        i = s >= 4 && 0 === e[s - 4] && 0 === e[s - 3] && 255 === e[s - 2] && 255 === e[s - 1];
                    if (this.inflate.push(e, i && p.Z_SYNC_FLUSH), !i) return;
                    t = this.inflate.result
                } else t = e;
                try {
                    s = n.unpack(t), this.manager.client.emit(a.RAW, s, this.id), s.op === l.DISPATCH && this.manager.emit(s.t, s.d, this.id)
                } catch (e) {
                    return void this.manager.client.emit(a.SHARD_ERROR, e, this.id)
                }
                this.onPacket(s)
            }
            onError(e) {
                const t = e && e.error ? e.error : e;
                t && this.manager.client.emit(a.SHARD_ERROR, t, this.id)
            }
            onClose(e) {
                -1 !== this.sequence && (this.closeSequence = this.sequence), this.sequence = -1, this.debug(`[CLOSE]\n    Event Code: ${e.code}\n    Clean     : ${e.wasClean}\n    Reason    : ${e.reason||"No reason received"}`), this.setHeartbeatTimer(-1), this.setHelloTimeout(-1), this.connection && this._cleanupConnection(), this.status = o.DISCONNECTED, this.emit(c.CLOSE, e)
            }
            onPacket(e) {
                if (e) {
                    switch (e.t) {
                        case h.READY:
                            this.emit(c.READY), this.sessionID = e.d.session_id, this.expectedGuilds = new Set(e.d.guilds.map(e => e.id)), this.status = o.WAITING_FOR_GUILDS, this.debug(`[READY] Session ${this.sessionID}.`), this.lastHeartbeatAcked = !0, this.sendHeartbeat("ReadyHeartbeat");
                            break;
                        case h.RESUMED: {
                            this.emit(c.RESUMED), this.status = o.READY;
                            const t = e.s - this.closeSequence;
                            this.debug(`[RESUMED] Session ${this.sessionID} | Replayed ${t} events.`), this.lastHeartbeatAcked = !0, this.sendHeartbeat("ResumeHeartbeat");
                            break
                        }
                    }
                    switch (e.s > this.sequence && (this.sequence = e.s), e.op) {
                        case l.HELLO:
                            this.setHelloTimeout(-1), this.setHeartbeatTimer(e.d.heartbeat_interval), this.identify();
                            break;
                        case l.RECONNECT:
                            this.destroy({
                                closeCode: 4e3
                            });
                            break;
                        case l.INVALID_SESSION:
                            if (this.debug(`[INVALID SESSION] Resumable: ${e.d}.`), e.d) return void this.identifyResume();
                            this.sequence = -1, this.sessionID = void 0, this.status = o.RECONNECTING, this.emit(c.INVALID_SESSION);
                            break;
                        case l.HEARTBEAT_ACK:
                            this.ackHeartbeat();
                            break;
                        case l.HEARTBEAT:
                            this.sendHeartbeat("HeartbeatRequest", !0);
                            break;
                        default:
                            this.manager.handlePacket(e, this), this.status === o.WAITING_FOR_GUILDS && e.t === h.GUILD_CREATE && (this.expectedGuilds.delete(e.d.id), this.checkReady())
                    }
                } else this.debug(`Received broken packet: '${e}'.`)
            }
            checkReady() {
                if (this.readyTimeout && (this.manager.client.clearTimeout(this.readyTimeout), this.readyTimeout = void 0), !this.expectedGuilds.size) return this.debug("Shard received all its guilds. Marking as fully ready."), this.status = o.READY, void this.emit(c.ALL_READY);
                this.readyTimeout = this.manager.client.setTimeout(() => {
                    this.debug(`Shard did not receive any more guild packets in 15 seconds.\n  Unavailable guild count: ${this.expectedGuilds.size}`), this.readyTimeout = void 0, this.status = o.READY, this.emit(c.ALL_READY, this.expectedGuilds)
                }, 15e3)
            }
            setHelloTimeout(e) {
                -1 !== e ? (this.debug("Setting a HELLO timeout for 20s."), this.helloTimeout = this.manager.client.setTimeout(() => {
                    this.debug("Did not receive HELLO in time. Destroying and connecting again."), this.destroy({
                        reset: !0,
                        closeCode: 4009
                    })
                }, 2e4)) : this.helloTimeout && (this.debug("Clearing the HELLO timeout."), this.manager.client.clearTimeout(this.helloTimeout), this.helloTimeout = void 0)
            }
            setHeartbeatTimer(e) {
                -1 !== e ? (this.debug(`Setting a heartbeat interval for ${e}ms.`), this.heartbeatInterval && this.manager.client.clearInterval(this.heartbeatInterval), this.heartbeatInterval = this.manager.client.setInterval(() => this.sendHeartbeat(), e)) : this.heartbeatInterval && (this.debug("Clearing the heartbeat interval."), this.manager.client.clearInterval(this.heartbeatInterval), this.heartbeatInterval = void 0)
            }
            sendHeartbeat(e = "HeartbeatTimer", t = [o.WAITING_FOR_GUILDS, o.IDENTIFYING, o.RESUMING].includes(this.status)) {
                if (t && !this.lastHeartbeatAcked) this.debug(`[${e}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);
                else if (!this.lastHeartbeatAcked) return this.debug(`[${e}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\n    Status          : ${u[this.status]}\n    Sequence        : ${this.sequence}\n    Connection State: ${this.connection?d[this.connection.readyState]:"No Connection??"}`), void this.destroy({
                    closeCode: 4009,
                    reset: !0
                });
                this.debug(`[${e}] Sending a heartbeat.`), this.lastHeartbeatAcked = !1, this.lastPingTimestamp = Date.now(), this.send({
                    op: l.HEARTBEAT,
                    d: this.sequence
                }, !0)
            }
            ackHeartbeat() {
                this.lastHeartbeatAcked = !0;
                const e = Date.now() - this.lastPingTimestamp;
                this.debug(`Heartbeat acknowledged, latency of ${e}ms.`), this.ping = e
            }
            identify() {
                return this.sessionID ? this.identifyResume() : this.identifyNew()
            }
            identifyNew() {
                const {
                    client: e
                } = this.manager;
                if (!e.token) return void this.debug("[IDENTIFY] No token available to identify a new session.");
                this.status = o.IDENTIFYING;
                const t = {
                    ...e.options.ws,
                    token: e.token,
                    shard: [this.id, Number(e.options.shardCount)]
                };
                this.debug(`[IDENTIFY] Shard ${this.id}/${e.options.shardCount}`), this.send({
                    op: l.IDENTIFY,
                    d: t
                }, !0)
            }
            identifyResume() {
                if (!this.sessionID) return this.debug("[RESUME] No session ID was present; identifying as a new session."), void this.identifyNew();
                this.status = o.RESUMING, this.debug(`[RESUME] Session ${this.sessionID}, sequence ${this.closeSequence}`);
                const e = {
                    token: this.manager.client.token,
                    session_id: this.sessionID,
                    seq: this.closeSequence
                };
                this.send({
                    op: l.RESUME,
                    d: e
                }, !0)
            }
            send(e, t = !1) {
                this.ratelimit.queue[t ? "unshift" : "push"](e), this.processQueue()
            }
            _send(e) {
                if (!this.connection || this.connection.readyState !== n.OPEN) return this.debug(`Tried to send packet '${JSON.stringify(e)}' but no WebSocket is available!`), void this.destroy({
                    close: 4e3
                });
                this.connection.send(n.pack(e), e => {
                    e && this.manager.client.emit(a.SHARD_ERROR, e, this.id)
                })
            }
            processQueue() {
                if (0 !== this.ratelimit.remaining && 0 !== this.ratelimit.queue.length)
                    for (this.ratelimit.remaining === this.ratelimit.total && (this.ratelimit.timer = this.manager.client.setTimeout(() => {
                            this.ratelimit.remaining = this.ratelimit.total, this.processQueue()
                        }, this.ratelimit.time)); this.ratelimit.remaining > 0;) {
                        const e = this.ratelimit.queue.shift();
                        if (!e) return;
                        this._send(e), this.ratelimit.remaining--
                    }
            }
            destroy({
                closeCode: e = 1e3,
                reset: t = !1,
                emit: s = !0,
                log: i = !0
            } = {}) {
                if (i && this.debug(`[DESTROY]\n    Close Code    : ${e}\n    Reset         : ${t}\n    Emit DESTROYED: ${s}`), this.setHeartbeatTimer(-1), this.setHelloTimeout(-1), this.connection)
                    if (this.connection.readyState === n.OPEN) this.connection.close(e);
                    else {
                        this.debug(`WS State: ${d[this.connection.readyState]}`), this._cleanupConnection();
                        try {
                            this.connection.close(e)
                        } catch {}
                        s && this._emitDestroyed()
                    }
                else s && this._emitDestroyed();
                this.connection = null, this.status = o.DISCONNECTED, -1 !== this.sequence && (this.closeSequence = this.sequence), t && (this.sequence = -1, this.sessionID = void 0), this.ratelimit.remaining = this.ratelimit.total, this.ratelimit.queue.length = 0, this.ratelimit.timer && (this.manager.client.clearTimeout(this.ratelimit.timer), this.ratelimit.timer = null)
            }
            _cleanupConnection() {
                this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null
            }
            _emitDestroyed() {
                this.emit(c.DESTROYED)
            }
        }
    }, function (e, t) {}, function (e, t, s) {
        (function (e) {
            var i = Object.getOwnPropertyDescriptors || function (e) {
                    for (var t = Object.keys(e), s = {}, i = 0; i < t.length; i++) s[t[i]] = Object.getOwnPropertyDescriptor(e, t[i]);
                    return s
                },
                n = /%[sdj%]/g;
            t.format = function (e) {
                if (!f(e)) {
                    for (var t = [], s = 0; s < arguments.length; s++) t.push(a(arguments[s]));
                    return t.join(" ")
                }
                s = 1;
                for (var i = arguments, r = i.length, o = String(e).replace(n, (function (e) {
                        if ("%%" === e) return "%";
                        if (s >= r) return e;
                        switch (e) {
                            case "%s":
                                return String(i[s++]);
                            case "%d":
                                return Number(i[s++]);
                            case "%j":
                                try {
                                    return JSON.stringify(i[s++])
                                } catch (e) {
                                    return "[Circular]"
                                }
                                default:
                                    return e
                        }
                    })), c = i[s]; s < r; c = i[++s]) g(c) || !A(c) ? o += " " + c : o += " " + a(c);
                return o
            }, t.deprecate = function (s, i) {
                if (void 0 !== e && !0 === e.noDeprecation) return s;
                if (void 0 === e) return function () {
                    return t.deprecate(s, i).apply(this, arguments)
                };
                var n = !1;
                return function () {
                    if (!n) {
                        if (e.throwDeprecation) throw new Error(i);
                        e.traceDeprecation ? console.trace(i) : console.error(i), n = !0
                    }
                    return s.apply(this, arguments)
                }
            };
            var r, o = {};

            function a(e, s) {
                var i = {
                    seen: [],
                    stylize: l
                };
                return arguments.length >= 3 && (i.depth = arguments[2]), arguments.length >= 4 && (i.colors = arguments[3]), m(s) ? i.showHidden = s : s && t._extend(i, s), _(i.showHidden) && (i.showHidden = !1), _(i.depth) && (i.depth = 2), _(i.colors) && (i.colors = !1), _(i.customInspect) && (i.customInspect = !0), i.colors && (i.stylize = c), h(i, e, i.depth)
            }

            function c(e, t) {
                var s = a.styles[t];
                return s ? "[" + a.colors[s][0] + "m" + e + "[" + a.colors[s][1] + "m" : e
            }

            function l(e, t) {
                return e
            }

            function h(e, s, i) {
                if (e.customInspect && s && D(s.inspect) && s.inspect !== t.inspect && (!s.constructor || s.constructor.prototype !== s)) {
                    var n = s.inspect(i, e);
                    return f(n) || (n = h(e, n, i)), n
                }
                var r = function (e, t) {
                    if (_(t)) return e.stylize("undefined", "undefined");
                    if (f(t)) {
                        var s = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                        return e.stylize(s, "string")
                    }
                    if (E(t)) return e.stylize("" + t, "number");
                    if (m(t)) return e.stylize("" + t, "boolean");
                    if (g(t)) return e.stylize("null", "null")
                }(e, s);
                if (r) return r;
                var o = Object.keys(s),
                    a = function (e) {
                        var t = {};
                        return e.forEach((function (e, s) {
                            t[e] = !0
                        })), t
                    }(o);
                if (e.showHidden && (o = Object.getOwnPropertyNames(s)), v(s) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0)) return u(s);
                if (0 === o.length) {
                    if (D(s)) {
                        var c = s.name ? ": " + s.name : "";
                        return e.stylize("[Function" + c + "]", "special")
                    }
                    if (I(s)) return e.stylize(RegExp.prototype.toString.call(s), "regexp");
                    if (y(s)) return e.stylize(Date.prototype.toString.call(s), "date");
                    if (v(s)) return u(s)
                }
                var l, A = "",
                    T = !1,
                    b = ["{", "}"];
                (p(s) && (T = !0, b = ["[", "]"]), D(s)) && (A = " [Function" + (s.name ? ": " + s.name : "") + "]");
                return I(s) && (A = " " + RegExp.prototype.toString.call(s)), y(s) && (A = " " + Date.prototype.toUTCString.call(s)), v(s) && (A = " " + u(s)), 0 !== o.length || T && 0 != s.length ? i < 0 ? I(s) ? e.stylize(RegExp.prototype.toString.call(s), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(s), l = T ? function (e, t, s, i, n) {
                    for (var r = [], o = 0, a = t.length; o < a; ++o) w(t, String(o)) ? r.push(d(e, t, s, i, String(o), !0)) : r.push("");
                    return n.forEach((function (n) {
                        n.match(/^\d+$/) || r.push(d(e, t, s, i, n, !0))
                    })), r
                }(e, s, i, a, o) : o.map((function (t) {
                    return d(e, s, i, a, t, T)
                })), e.seen.pop(), function (e, t, s) {
                    if (e.reduce((function (e, t) {
                            return t.indexOf("\n") >= 0 && 0, e + t.replace(/\u001b\[\d\d?m/g, "").length + 1
                        }), 0) > 60) return s[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + s[1];
                    return s[0] + t + " " + e.join(", ") + " " + s[1]
                }(l, A, b)) : b[0] + A + b[1]
            }

            function u(e) {
                return "[" + Error.prototype.toString.call(e) + "]"
            }

            function d(e, t, s, i, n, r) {
                var o, a, c;
                if ((c = Object.getOwnPropertyDescriptor(t, n) || {
                        value: t[n]
                    }).get ? a = c.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : c.set && (a = e.stylize("[Setter]", "special")), w(i, n) || (o = "[" + n + "]"), a || (e.seen.indexOf(c.value) < 0 ? (a = g(s) ? h(e, c.value, null) : h(e, c.value, s - 1)).indexOf("\n") > -1 && (a = r ? a.split("\n").map((function (e) {
                        return "  " + e
                    })).join("\n").substr(2) : "\n" + a.split("\n").map((function (e) {
                        return "   " + e
                    })).join("\n")) : a = e.stylize("[Circular]", "special")), _(o)) {
                    if (r && n.match(/^\d+$/)) return a;
                    (o = JSON.stringify("" + n)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.substr(1, o.length - 2), o = e.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o = e.stylize(o, "string"))
                }
                return o + ": " + a
            }

            function p(e) {
                return Array.isArray(e)
            }

            function m(e) {
                return "boolean" == typeof e
            }

            function g(e) {
                return null === e
            }

            function E(e) {
                return "number" == typeof e
            }

            function f(e) {
                return "string" == typeof e
            }

            function _(e) {
                return void 0 === e
            }

            function I(e) {
                return A(e) && "[object RegExp]" === T(e)
            }

            function A(e) {
                return "object" == typeof e && null !== e
            }

            function y(e) {
                return A(e) && "[object Date]" === T(e)
            }

            function v(e) {
                return A(e) && ("[object Error]" === T(e) || e instanceof Error)
            }

            function D(e) {
                return "function" == typeof e
            }

            function T(e) {
                return Object.prototype.toString.call(e)
            }

            function b(e) {
                return e < 10 ? "0" + e.toString(10) : e.toString(10)
            }
            t.debuglog = function (s) {
                if (_(r) && (r = e.env.NODE_DEBUG || ""), s = s.toUpperCase(), !o[s])
                    if (new RegExp("\\b" + s + "\\b", "i").test(r)) {
                        var i = e.pid;
                        o[s] = function () {
                            var e = t.format.apply(t, arguments);
                            console.error("%s %d: %s", s, i, e)
                        }
                    } else o[s] = function () {};
                return o[s]
            }, t.inspect = a, a.colors = {
                bold: [1, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                white: [37, 39],
                grey: [90, 39],
                black: [30, 39],
                blue: [34, 39],
                cyan: [36, 39],
                green: [32, 39],
                magenta: [35, 39],
                red: [31, 39],
                yellow: [33, 39]
            }, a.styles = {
                special: "cyan",
                number: "yellow",
                boolean: "yellow",
                undefined: "grey",
                null: "bold",
                string: "green",
                date: "magenta",
                regexp: "red"
            }, t.isArray = p, t.isBoolean = m, t.isNull = g, t.isNullOrUndefined = function (e) {
                return null == e
            }, t.isNumber = E, t.isString = f, t.isSymbol = function (e) {
                return "symbol" == typeof e
            }, t.isUndefined = _, t.isRegExp = I, t.isObject = A, t.isDate = y, t.isError = v, t.isFunction = D, t.isPrimitive = function (e) {
                return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e
            }, t.isBuffer = s(136);
            var S = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

            function N() {
                var e = new Date,
                    t = [b(e.getHours()), b(e.getMinutes()), b(e.getSeconds())].join(":");
                return [e.getDate(), S[e.getMonth()], t].join(" ")
            }

            function w(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t)
            }
            t.log = function () {
                console.log("%s - %s", N(), t.format.apply(t, arguments))
            }, t.inherits = s(137), t._extend = function (e, t) {
                if (!t || !A(t)) return e;
                for (var s = Object.keys(t), i = s.length; i--;) e[s[i]] = t[s[i]];
                return e
            };
            var O = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;

            function C(e, t) {
                if (!e) {
                    var s = new Error("Promise was rejected with a falsy value");
                    s.reason = e, e = s
                }
                return t(e)
            }
            t.promisify = function (e) {
                if ("function" != typeof e) throw new TypeError('The "original" argument must be of type Function');
                if (O && e[O]) {
                    var t;
                    if ("function" != typeof (t = e[O])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                    return Object.defineProperty(t, O, {
                        value: t,
                        enumerable: !1,
                        writable: !1,
                        configurable: !0
                    }), t
                }

                function t() {
                    for (var t, s, i = new Promise((function (e, i) {
                            t = e, s = i
                        })), n = [], r = 0; r < arguments.length; r++) n.push(arguments[r]);
                    n.push((function (e, i) {
                        e ? s(e) : t(i)
                    }));
                    try {
                        e.apply(this, n)
                    } catch (e) {
                        s(e)
                    }
                    return i
                }
                return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), O && Object.defineProperty(t, O, {
                    value: t,
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                }), Object.defineProperties(t, i(e))
            }, t.promisify.custom = O, t.callbackify = function (t) {
                if ("function" != typeof t) throw new TypeError('The "original" argument must be of type Function');

                function s() {
                    for (var s = [], i = 0; i < arguments.length; i++) s.push(arguments[i]);
                    var n = s.pop();
                    if ("function" != typeof n) throw new TypeError("The last argument must be of type Function");
                    var r = this,
                        o = function () {
                            return n.apply(r, arguments)
                        };
                    t.apply(this, s).then((function (t) {
                        e.nextTick(o, null, t)
                    }), (function (t) {
                        e.nextTick(C, t, o)
                    }))
                }
                return Object.setPrototypeOf(s, Object.getPrototypeOf(t)), Object.defineProperties(s, i(t)), s
            }
        }).call(this, s(23))
    }, function (e, t) {
        e.exports = function (e) {
            return e && "object" == typeof e && "function" == typeof e.copy && "function" == typeof e.fill && "function" == typeof e.readUInt8
        }
    }, function (e, t) {
        "function" == typeof Object.create ? e.exports = function (e, t) {
            e.super_ = t, e.prototype = Object.create(t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            })
        } : e.exports = function (e, t) {
            e.super_ = t;
            var s = function () {};
            s.prototype = t.prototype, e.prototype = new s, e.prototype.constructor = e
        }
    }, function (e, t) {}, function (e, t) {}, function (e, t, s) {
        var i = {
            "./CHANNEL_CREATE.js": 141,
            "./CHANNEL_DELETE.js": 142,
            "./CHANNEL_PINS_UPDATE.js": 143,
            "./CHANNEL_UPDATE.js": 144,
            "./GUILD_BAN_ADD.js": 145,
            "./GUILD_BAN_REMOVE.js": 146,
            "./GUILD_CREATE.js": 147,
            "./GUILD_DELETE.js": 148,
            "./GUILD_EMOJIS_UPDATE.js": 149,
            "./GUILD_INTEGRATIONS_UPDATE.js": 150,
            "./GUILD_MEMBERS_CHUNK.js": 151,
            "./GUILD_MEMBER_ADD.js": 152,
            "./GUILD_MEMBER_REMOVE.js": 153,
            "./GUILD_MEMBER_UPDATE.js": 154,
            "./GUILD_ROLE_CREATE.js": 155,
            "./GUILD_ROLE_DELETE.js": 156,
            "./GUILD_ROLE_UPDATE.js": 157,
            "./GUILD_UPDATE.js": 158,
            "./INVITE_CREATE.js": 159,
            "./INVITE_DELETE.js": 160,
            "./MESSAGE_CREATE.js": 161,
            "./MESSAGE_DELETE.js": 162,
            "./MESSAGE_DELETE_BULK.js": 163,
            "./MESSAGE_REACTION_ADD.js": 164,
            "./MESSAGE_REACTION_REMOVE.js": 165,
            "./MESSAGE_REACTION_REMOVE_ALL.js": 166,
            "./MESSAGE_REACTION_REMOVE_EMOJI.js": 167,
            "./MESSAGE_UPDATE.js": 168,
            "./PRESENCE_UPDATE.js": 169,
            "./READY.js": 170,
            "./RESUMED.js": 171,
            "./TYPING_START.js": 172,
            "./USER_UPDATE.js": 173,
            "./VOICE_SERVER_UPDATE.js": 174,
            "./VOICE_STATE_UPDATE.js": 175,
            "./WEBHOOKS_UPDATE.js": 176,
            "./index.js": 77
        };

        function n(e) {
            var t = r(e);
            return s(t)
        }

        function r(e) {
            if (!s.o(i, e)) {
                var t = new Error("Cannot find module '" + e + "'");
                throw t.code = "MODULE_NOT_FOUND", t
            }
            return i[e]
        }
        n.keys = function () {
            return Object.keys(i)
        }, n.resolve = r, e.exports = n, n.id = 140
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.ChannelCreate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.ChannelDelete.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        const {
            Events: i
        } = s(0);
        e.exports = (e, {
            d: t
        }) => {
            const s = e.channels.cache.get(t.channel_id),
                n = new Date(t.last_pin_timestamp);
            s && !Number.isNaN(n.getTime()) && (s.lastPinTimestamp = n.getTime() || null, e.emit(i.CHANNEL_PINS_UPDATE, s, n))
        }
    }, function (e, t, s) {
        "use strict";
        const {
            Events: i
        } = s(0);
        e.exports = (e, t) => {
            const {
                old: s,
                updated: n
            } = e.actions.ChannelUpdate.handle(t.d);
            s && n && e.emit(i.CHANNEL_UPDATE, s, n)
        }
    }, function (e, t, s) {
        "use strict";
        const {
            Events: i
        } = s(0);
        e.exports = (e, {
            d: t
        }) => {
            const s = e.guilds.cache.get(t.guild_id),
                n = e.users.add(t.user);
            s && n && e.emit(i.GUILD_BAN_ADD, s, n)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.GuildBanRemove.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        const {
            Events: i,
            Status: n
        } = s(0);
        e.exports = async (e, {
            d: t
        }, s) => {
            let r = e.guilds.cache.get(t.id);
            r ? r.available || t.unavailable || (r._patch(t), e.ws.status === n.READY && e.options.fetchAllMembers && await r.members.fetch().catch(t => e.emit(i.DEBUG, `Failed to fetch all members: ${t}\n${t.stack}`))) : (t.shardID = s.id, r = e.guilds.add(t), e.ws.status === n.READY && (e.options.fetchAllMembers && await r.members.fetch().catch(t => e.emit(i.DEBUG, `Failed to fetch all members: ${t}\n${t.stack}`)), e.emit(i.GUILD_CREATE, r)))
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.GuildDelete.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.GuildEmojisUpdate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.GuildIntegrationsUpdate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        const i = s(2),
            {
                Events: n
            } = s(0);
        e.exports = (e, {
            d: t
        }) => {
            const s = e.guilds.cache.get(t.guild_id);
            if (!s) return;
            const r = new i;
            for (const e of t.members) r.set(e.user.id, s.members.add(e));
            if (t.presences)
                for (const e of t.presences) s.presences.cache.add(Object.assign(e, {
                    guild: s
                }));
            e.emit(n.GUILD_MEMBERS_CHUNK, r, s)
        }
    }, function (e, t, s) {
        "use strict";
        const {
            Events: i,
            Status: n
        } = s(0);
        e.exports = (e, {
            d: t
        }, s) => {
            const r = e.guilds.cache.get(t.guild_id);
            if (r) {
                r.memberCount++;
                const o = r.members.add(t);
                s.status === n.READY && e.emit(i.GUILD_MEMBER_ADD, o)
            }
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t, s) => {
            e.actions.GuildMemberRemove.handle(t.d, s)
        }
    }, function (e, t, s) {
        "use strict";
        const {
            Status: i,
            Events: n
        } = s(0);
        e.exports = (e, {
            d: t
        }, s) => {
            const r = e.guilds.cache.get(t.guild_id);
            if (r) {
                const o = r.members.cache.get(t.user.id);
                if (o) {
                    const r = o._update(t);
                    s.status === i.READY && e.emit(n.GUILD_MEMBER_UPDATE, r, o)
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.GuildRoleCreate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.GuildRoleDelete.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.GuildRoleUpdate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.GuildUpdate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.InviteCreate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.InviteDelete.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.MessageCreate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.MessageDelete.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.MessageDeleteBulk.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.MessageReactionAdd.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.MessageReactionRemove.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.MessageReactionRemoveAll.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.MessageReactionRemoveEmoji.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        const {
            Events: i
        } = s(0);
        e.exports = (e, t) => {
            const {
                old: s,
                updated: n
            } = e.actions.MessageUpdate.handle(t.d);
            s && n && e.emit(i.MESSAGE_UPDATE, s, n)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.PresenceUpdate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        let i;
        e.exports = (e, {
            d: t
        }, n) => {
            if (e.user) e.user._patch(t.user);
            else {
                i || (i = s(78));
                const n = new i(e, t.user);
                e.user = n, e.users.cache.set(n.id, n)
            }
            for (const s of t.guilds) s.shardID = n.id, e.guilds.add(s);
            n.checkReady()
        }
    }, function (e, t, s) {
        "use strict";
        const {
            Events: i
        } = s(0);
        e.exports = (e, t, s) => {
            const n = s.sequence - s.closeSequence;
            e.emit(i.SHARD_RESUME, s.id, n)
        }
    }, function (e, t, s) {
        "use strict";
        const {
            Events: i
        } = s(0);

        function n(e, t) {
            return e.client.setTimeout(() => {
                e._typing.delete(t.id)
            }, 1e4)
        }
        e.exports = (e, {
            d: t
        }) => {
            const s = e.channels.cache.get(t.channel_id),
                r = e.users.cache.get(t.user_id),
                o = new Date(1e3 * t.timestamp);
            if (s && r) {
                if ("voice" === s.type) return void e.emit(i.WARN, `Discord sent a typing packet to a voice channel ${s.id}`);
                if (s._typing.has(r.id)) {
                    const t = s._typing.get(r.id);
                    t.lastTimestamp = o, t.elapsedTime = Date.now() - t.since, e.clearTimeout(t.timeout), t.timeout = n(s, r)
                } else {
                    const t = new Date,
                        o = new Date;
                    s._typing.set(r.id, {
                        user: r,
                        since: t,
                        lastTimestamp: o,
                        elapsedTime: Date.now() - t,
                        timeout: n(s, r)
                    }), e.emit(i.TYPING_START, s, r)
                }
            }
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.UserUpdate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.emit("debug", `[VOICE] received voice server: ${JSON.stringify(t)}`), e.voice.onVoiceServer(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.VoiceStateUpdate.handle(t.d)
        }
    }, function (e, t, s) {
        "use strict";
        e.exports = (e, t) => {
            e.actions.WebhooksUpdate.handle(t.d)
        }
    }, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t) {}, function (e, t, s) {
        "use strict";
        const i = s(14);
        class Speaking extends i {}
        Speaking.FLAGS = {
            SPEAKING: 1,
            SOUNDSHARE: 2,
            PRIORITY_SPEAKING: 4
        }, e.exports = Speaking
    }])
}));